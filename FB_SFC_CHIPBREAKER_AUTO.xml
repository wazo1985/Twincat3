<?xml version="1.0" encoding="utf-8"?>
<project xmlns="http://www.plcopen.org/xml/tc6_0200">
  <fileHeader companyName="Beckhoff Automation GmbH" productName="TwinCAT PLC Control" productVersion="3.5.13.20" creationDateTime="2021-05-25T13:03:07.2332886" />
  <contentHeader name="LorochCxPlc_1" modificationDateTime="2021-05-25T13:03:07.2402695">
    <coordinateInfo>
      <fbd>
        <scaling x="1" y="1" />
      </fbd>
      <ld>
        <scaling x="1" y="1" />
      </ld>
      <sfc>
        <scaling x="1" y="1" />
      </sfc>
    </coordinateInfo>
    <addData>
      <data name="http://www.3s-software.com/plcopenxml/projectinformation" handleUnknown="implementation">
        <ProjectInformation />
      </data>
    </addData>
  </contentHeader>
  <types>
    <dataTypes />
    <pous>
      <pou name="FB_SFC_CHIPBREAKER_AUTO" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="YDistanceToTouchPos">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Positionierung Manuelle</xhtml>
              </documentation>
            </variable>
            <variable name="ManPosActive">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="XMoveManual">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="SimpleTouch">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Only 1 Touch</xhtml>
              </documentation>
            </variable>
            <variable name="KeyNextStep">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="YrefPos">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Reference Position  of Y-Axis)</xhtml>
              </documentation>
            </variable>
            <variable name="DoubleTouch">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="WorkingAngle">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="Reset">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="PauseSwitchActive">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="MachineStateSafetyStateActive">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="MachineStateSharpenerDoorIsClosed">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="Start">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="AutomaticMode">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="ActualSawBlade">
              <type>
                <derived name="ST_SawBlade" />
              </type>
            </variable>
            <variable name="ActualGrindingWheel">
              <type>
                <derived name="ST_GrindingWheel" />
              </type>
            </variable>
            <variable name="ActualJob">
              <type>
                <derived name="ST_Job" />
              </type>
            </variable>
            <variable name="AStartPos">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Rear Pos</xhtml>
              </documentation>
            </variable>
            <variable name="ChamferSideString">
              <type>
                <string />
              </type>
            </variable>
            <variable name="ToothPitch">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="GrindingDirCW">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="DeltaMax">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="TeethNumber">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="Stepper">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Using Servo Motor</xhtml>
              </documentation>
            </variable>
            <variable name="CbaPneumatic">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="Zx">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Z_Axis Corrector</xhtml>
              </documentation>
            </variable>
            <variable name="MarginRearValue">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">this value: Randabstand rear side to be set by the user</xhtml>
              </documentation>
            </variable>
            <variable name="MarginFrontValue">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">this value: Randabstand front side to be set by the user</xhtml>
              </documentation>
            </variable>
            <variable name="CbaMotionType">
              <type>
                <derived name="E_MotionType" />
              </type>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="ActualStep">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="ErrorID">
              <type>
                <DINT />
              </type>
            </variable>
            <variable name="ErrorOut">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="Paused">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="PauseRequest">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="PauseAvailable">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="CammingActive">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="ActualRevolutions">
              <type>
                <UINT />
              </type>
            </variable>
            <variable name="ZStartposBuffered">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ActualInfeed">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> actual infeed </xhtml>
              </documentation>
            </variable>
            <variable name="PartialInfeed">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ToothCount">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="ZaxisCbaLimit">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="CBAutoNotPossibleWithTooLargeSbDiameter">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="WarningAaxisIsSlow">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="CbaSpindleLowSpeedOutput">
              <type>
                <BOOL />
              </type>
            </variable>
          </outputVars>
          <inOutVars>
            <variable name="Done">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="TouchPositionZAxis">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ChipBreakerAutoVeloTemp">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ChipBreakerManVeloOverrideFactor">
              <type>
                <LREAL />
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="RTrigConfirmTouchposZ">
              <type>
                <derived name="R_TRIG" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Manual Positionning</xhtml>
              </documentation>
            </variable>
            <variable name="RTrigConfirmTouchposX">
              <type>
                <derived name="R_TRIG" />
              </type>
            </variable>
            <variable name="TON_Wait">
              <type>
                <derived name="TON" />
              </type>
            </variable>
            <variable name="DeltaXChamfering">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ActualTeeth">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="SfcChipBreakerAuto">
              <type>
                <derived name="FB_SUBFUNC_SEQ_CONTROL" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> FB sfc </xhtml>
              </documentation>
            </variable>
            <variable name="XAxisStartPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ZAxisStartPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ChipBreakerRear">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="StepNew">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="StepAction">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="StepActionImPulse">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="PauseStep">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="WorkingStepNo">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="AxisState">
              <type>
                <derived name="E_StateMachineAxis" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> check state of axis </xhtml>
              </documentation>
            </variable>
            <variable name="SBCircumference">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ChipBreakerXAxisVelo">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ChipBreakerAutoXAxisMaxVelo">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="YAxisStartPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="DegPerTeeth">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="XAxisTouchposRadio">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="TouchCorrection">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="FBCalcXOffset">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="XOffset">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ZOffset">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="VarioCtr">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="VarioCtrEnd">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="XAxisEndPos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ZTouchPos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="NumberTouch">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="Delta">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">ABS(TP1-TP2)</xhtml>
              </documentation>
            </variable>
            <variable name="NominalTeeth">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="PauseRequested">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="PartialInfeedChangedDownfeed">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="ZAxisPausePos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="InfeedZAxisMM">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="TouchPositionsZPlausi">
              <type>
                <array>
                  <dimension lower="0" upper="2" />
                  <baseType>
                    <LREAL />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="TouchPositionsPlausibilityOK">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="TouchPositionsPlausibilityError">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="ChipBreakerFront">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="XaxisEndPOsFront">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">X-Axis End Position After The Sharpening </xhtml>
              </documentation>
            </variable>
            <variable name="DeltaX">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="DeltaZ">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="YendPos">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">End Position Y-Axis after Grinding</xhtml>
              </documentation>
            </variable>
            <variable name="ZAxisUpfeedMM">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ZAxisUpfeedPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="WorkingAngleRAD">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="RSS">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="BSS">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ChipBreakerFr">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="TRUE" />
              </initialValue>
            </variable>
            <variable name="ChipBreakerRe">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="FALSE" />
              </initialValue>
            </variable>
            <variable name="NumberRevolution">
              <type>
                <INT />
              </type>
              <initialValue>
                <simpleValue value="0" />
              </initialValue>
            </variable>
            <variable name="ActualGrindingWheelThickness">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="RTrigNextStep">
              <type>
                <derived name="R_TRIG" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Enumeration added</xhtml>
              </documentation>
            </variable>
            <variable name="ContinousMode">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="NextStepPulse">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="XPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ZPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="TON_Rear">
              <type>
                <derived name="TON" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Delay before the start of the Rear Side</xhtml>
              </documentation>
            </variable>
            <variable name="TONWaitSafetyStatePause">
              <type>
                <derived name="TON" />
              </type>
            </variable>
            <variable name="FTRIG_STOP">
              <type>
                <derived name="F_TRIG" />
              </type>
            </variable>
            <variable name="DeltaX_DEG">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="XoffsetInGrad">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="TonWaitClamping">
              <type>
                <derived name="TON" />
              </type>
            </variable>
            <variable name="Test">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="StopChipBreaker">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="StartButton">
              <type>
                <derived name="R_TRIG" />
              </type>
            </variable>
            <variable name="Stop_Manual_Pos">
              <type>
                <derived name="F_TRIG" />
              </type>
            </variable>
            <variable name="DSSDiff">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ZPosAfterSharpening">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ZAxisLimitPos">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Software Limit S</xhtml>
              </documentation>
            </variable>
            <variable name="R_TRIG_ZlimitPos">
              <type>
                <derived name="R_TRIG" />
              </type>
            </variable>
            <variable name="CbaLimit">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="WaitAfterPause">
              <type>
                <derived name="TON" />
              </type>
            </variable>
            <variable name="VarioToothPitch">
              <type>
                <array>
                  <dimension lower="0" upper="11" />
                  <baseType>
                    <LREAL />
                  </baseType>
                </array>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Vario</xhtml>
              </documentation>
            </variable>
            <variable name="VarioCtrFront1">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="VarioCtrFront2">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="VarioCtrRear1">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="VarioCtrRear2">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="GearPlayXAxis">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="DifferenceMaxMinCBAGWDiameter">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="UIEventCBAProtection">
              <type>
                <derived name="FB_SUBFUNC_MESSAGE" />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Display Warning</xhtml>
              </documentation>
            </variable>
            <variable name="ChipBreakerAutoGWwidth">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="AaxisReferenceValue">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">the initial distance in MM when the axis is in home position</xhtml>
              </documentation>
            </variable>
            <variable name="AFront80">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">80% of the A-Axis front destination</xhtml>
              </documentation>
            </variable>
            <variable name="ARear80">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">80 % of the A -Axis Rear position </xhtml>
              </documentation>
            </variable>
            <variable name="AaxisRef80">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ARearPos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="AFrontPos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="TonMonitoringAaxis">
              <type>
                <derived name="TON" />
              </type>
            </variable>
            <variable name="StartMonitoringAaxis">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="WarningAaxis">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="RtrigAaxisIsTooSlow">
              <type>
                <derived name="R_TRIG" />
              </type>
            </variable>
            <variable name="RtrigSpindleLowSpeedError">
              <type>
                <derived name="R_TRIG" />
              </type>
            </variable>
            <variable name="CbaSpindleLowSpeed">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="TriesNumber">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">Number of tries to find out the Reference position of A-axis</xhtml>
              </documentation>
            </variable>
            <variable name="AaxisRefPosTemp">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="AaxisActPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="StartMovingStepByStepRear">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="StartMovingStepByStepFront">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="ZTouchPosFirstTouchPos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="AaxisStepPositionIsReached">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="WaitForAaxis">
              <type>
                <derived name="TON" />
              </type>
            </variable>
            <variable name="StartWaitAaxis">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="ZaxisFirstTouchPos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="ZNoTouch">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="LastZPos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="LimitZaxis">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="Zcomp">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="StepperResults">
              <type>
                <derived name="FB_StepperResults" />
              </type>
            </variable>
            <variable name="FileNameExtension">
              <type>
                <derived name="T_MaxString" />
              </type>
            </variable>
            <variable name="StartWriting">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="FileName">
              <type>
                <string />
              </type>
            </variable>
            <variable name="stTimeStruct">
              <type>
                <derived name="TIMESTRUCT" />
              </type>
            </variable>
            <variable name="stTimeStartM">
              <type>
                <derived name="TIMESTRUCT" />
              </type>
            </variable>
            <variable name="stTimeEndM">
              <type>
                <derived name="TIMESTRUCT" />
              </type>
            </variable>
            <variable name="ZposForCsv">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="DurationAaxisMotion">
              <type>
                <TIME />
              </type>
            </variable>
            <variable name="StartTimeCounting">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="TonCounting">
              <type>
                <derived name="TP" />
              </type>
            </variable>
            <variable name="fbGetTime">
              <type>
                <derived name="NT_GetTime" />
              </type>
            </variable>
            <variable name="FirstEdgePos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="TestZ">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="SecondEdge">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="StepMotorNeededTimeToMove">
              <type>
                <TIME />
              </type>
            </variable>
            <variable name="StepMotorDestination">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="AaxisTolerenceFast">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="AaxisTolerenceSlow">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="RTrigMonitoringCrash">
              <type>
                <derived name="R_TRIG" />
              </type>
            </variable>
            <variable name="MonitoringTouchBack">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="MonitoringTouchFront">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="OperatingDirection">
              <type>
                <derived name="ST_OperatingDirection" />
              </type>
            </variable>
            <variable name="TestCW">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="TestCCW">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="CalculatedXPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="DiffXactposXcalcPos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="NumberOfTeethToAddReal">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="NumberOfTeethToAdd">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="rValueToAdd">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="NombreOfRevolution">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="GearPlayXAxisSharpChamfer">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="NoOfActTeethCompensation">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Compensation </xhtml>
              </documentation>
            </variable>
            <variable name="XAxisNextPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="TestArray">
              <type>
                <array>
                  <dimension lower="0" upper="5" />
                  <baseType>
                    <BOOL />
                  </baseType>
                </array>
              </type>
            </variable>
          </localVars>
        </interface>
        <actions>
          <action name="ACT_Pneumatic">
            <body>
              <ST>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">

CASE	SfcChipBreakerAuto.Step	OF

	(*-----------------------------------------------------Transition Pneumatic Cylinder-10------------------------------------------------------*)
	990	:		(*Transition*)
					IF 	ChipBreakerFr
						THEN
							StepNew		:=	1000;			(*ChipBreakerFront With Pneumatic Cylindre *)
						ELSIF	ChipBreakerRe AND
								(NOT ChipBreakerFr)
						THEN
							StepNew			:=	1100;		(*ChipBreaker Rear  With Pneumatic Cylindre *)
							NumberTouch	:=	0;			(*Init number of touch to 0*)
					END_IF;
	(*--------------------------------------------------------ChipBreakerFront With Cylindre --------------------------------------------------------*)
	1000	:		(*Action*)
					IF 	StepActionImpulse AND
						(NOT MachineCtrl.State.ChipBreaker.Auto.TurbinePosition.InFrontPosition)
						THEN
							IF	NOT UI.MachineSpecification.Base.DemoMode
								THEN
									MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdBackward	:=	FALSE;
									MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdForward	:=	TRUE;
							END_IF;
					END_IF;
					(*Transition*)
					IF 	StepAction AND
						(NOT StepActionImpulse) AND
						(NOT MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdForward) AND
						( MachineCtrl.State.ChipBreaker.Auto.TurbinePosition.InFrontPosition OR
						UI.MachineSpecification.Base.DemoMode)
						THEN
							StepNew		:=	1010;			(*Move Z-Axis Up *)
					END_IF;
	(*------------------------------------------------------------Wait For User Interaction---------------------------------------------------------------*)
	1010:			(*Action*)
					IF	StepActionImpulse
						THEN
							NextStepPulse	:=	TRUE;
					END_IF;
					(*Transition*)
					IF	StepAction AND
						( RTrigNextStep.Q OR
						ContinousMode )
						THEN
							StepNew			:= 	1220;		(*Move Z-Axis Up *)
							NextStepPulse	:=	FALSE;
					END_IF;
	(*----------------------------------------------------------Wait For User Interaction---------------------------------------------------------------*)
	1100:			(*Action*)
					IF	StepActionImpulse
						THEN
							NextStepPulse	:=	TRUE;
					END_IF;
					(*Transition*)
					IF	StepAction AND
						( RTrigNextStep.Q OR
						ContinousMode )
						THEN
							StepNew			:= 	1110;
							NextStepPulse	:=	FALSE;
					END_IF;
END_CASE;
</xhtml>
              </ST>
            </body>
            <addData>
              <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
                <ObjectId>546b885e-675a-4e8c-bcf1-7440e2a398b1</ObjectId>
              </data>
            </addData>
          </action>
          <action name="ACT_Stepper">
            <body>
              <ST>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">

CASE	SfcChipBreakerAuto.Step	OF

	(*-----------------------------------------------ChipBreakerRearPosUsingServoMotor------------------------------------------------*)
	975:			(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	0.3;
						IF	(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  ARearPos)
							THEN
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus		:=	FALSE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus		:=	TRUE;
							ELSE
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus		:=	TRUE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus		:=	FALSE;
						END_IF;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT StepActionImpulse) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  (ARearPos +AaxisTolerenceSlow)) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (ARearPos -AaxisTolerenceSlow))
					THEN
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus			:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus			:=	FALSE;		(*Stop Moving   A-Axis*)
						StepNew				:=	 1100;
						StartMonitoringAaxis	:=	FALSE;
				END_IF;
	(*-----------------------------------------------1: front------------------Wait For User Interaction----------------------------------------------------*)
	980:			(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					TestZ )
					THEN
						StartMonitoringAaxis	:=	TRUE;
						IF 	(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;= AaxisRefPosTemp)
							THEN
								StepNew			:= 	981;  		(*Start moving in the negative direction in order to reach the reference position*)
								AaxisActPosition	:=	MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos ;
								StartMovingStepByStepRear		:=	TRUE;
								StartMovingStepByStepFront		:=	FALSE;
							ELSE
								StepNew			:= 	9882;;		(*Start moving in the positive  direction in order to reach the reference position*)
								AaxisActPosition	:=	MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos ;
								StartMovingStepByStepRear		:=	FALSE;
								StartMovingStepByStepFront		:=	TRUE;;
								AaxisRefPosTemp	:=	AaxisRefPosTemp - (0.5*UI.Order.SawBlade.Width);  (*0.2*)
								StepMotorDestination	:=	AaxisRefPosTemp;
						END_IF;
						StepMotorDestination	:=	AaxisRefPosTemp;
						AaxisActPosition		:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
				END_IF;
	(*----------------------------------Action:Move A-Axis To Reference Position ,moving with minus : Backward ---------------------------------*)
	981:			(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog					:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog					:=	1;
						IF	(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos&lt;=  AaxisRefPosTemp )
							THEN
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus		:=	FALSE;;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus		:=	TRUE;;
							ELSE
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus		:=	TRUE;;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus		:=	FALSE;;
						END_IF;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT  StepActionImpulse) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (AaxisRefPosTemp- AaxisTolerenceFast)) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  ( AaxisRefPosTemp + AaxisTolerenceFast))
					THEN
						StepNew				:=		995;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;
						StartMonitoringAaxis	:=	FALSE;
						AaxisRefPosTemp	:=	MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos - (0.5*UI.Order.SawBlade.Width);
						MonitoringTouchBack	:=	AaxisRefPosTemp - 0.01;
				END_IF;
	(*------------------------------------------------------move forward to make sure that the grindinfg whee will touch the sb----------------------*)
	995:			(*Transition*)
				IF	StepActionImpulse
					THEN
						NextStepPulse		:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					TestZ )
					THEN
						StepNew				:= 	996;				(* Moving stepper backward befor moving up Z-axis  *)
						NextStepPulse		:=	FALSE;
						StartMonitoringAaxis	:=	TRUE;
						StepMotorDestination	:=	AaxisRefPosTemp;
						AaxisActPosition		:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
				END_IF;
	(*-----------------------------------------------Moving Stepper Backward before moving z-axis Up--------------------------------------------------*)
	996:
				(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	1;
						IF	(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  AaxisRefPosTemp)
							THEN
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus		:=	TRUE;;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus		:=	FALSE;;
							ELSE
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus		:=	FALSE;;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus		:=	TRUE;;;
						END_IF;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT  StepActionImpulse) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (AaxisRefPosTemp- AaxisTolerenceFast )) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  ( AaxisRefPosTemp + AaxisTolerenceFast ))
					THEN
						StepNew				:= 9810;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
						StartMonitoringAaxis	:=	FALSE;
				END_IF;
	(*-------------------------------------------------------------------------find out the reference position ---------------------------------------------------------*)
	9810:		(* Action *)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	9815;				(* *)
						NextStepPulse	:=	FALSE;
				END_IF;
	(*----------------------------------------------------Move the Z axis up with touch probe active---------------------------------------------------*)
	9815:
				(*Action*)
				IF	StepActionImPulse
					THEN
						StartMonitoringAaxis	:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut				:=	2;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut				:= 	Axis[AxisNo.ZAxis].NcToPlc.ActPos - 14;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT StepActionImPulse) AND
					(NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe )
					THEN
						IF	( AxisCtrl[AxisNo.ZAxis].Feedback.State.TouchProbe.ActiveAndAxisStopped)
							THEN
								TriesNumber	:=	TriesNumber +1 ;

								ZTouchPos				:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos;
								IF	(TriesNumber = 1)
									THEN
										ZTouchPosFirstTouchPos	:=	ZTouchPos;
										ZNoTouch				:=	ZTouchPosFirstTouchPos - 1;  (*0.3*)
										ZposForCsv				:=	ZTouchPosFirstTouchPos;
								END_IF;

								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	FALSE;
								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	FALSE;
								StepNew			:=	9817;
						END_IF;
						(*Check of the touch number *)
						IF	(TriesNumber &gt;=1)
							THEN
								StepNew						:=	9817;
								AaxisStepPositionIsReached	:=	TRUE;
								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut	:=	FALSE;
								LastZPos					:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos ;
						END_IF;
						(*if no touch detected --&gt; Warning  *)
						IF	(Axis[AxisNo.ZAxis].NcToPlc.ActPos &lt;  LimitZaxis)
							THEN
								StepNew		:=	6000;;						(*If There is No Touch --&gt; ERROR*)
								MachineCtrl.ProcessControl.Warning.No		:=	PSM_Fault_ErrorChipBreakerAuto;
								MachineCtrl.ProcessControl.Warning.En		:=	TRUE;
								MachineCtrl.Peripheral.Buzzer.Unit.CmdOn	:=	TRUE;
								MachineCtrl.ProcessControl.Warning.Data		:=	'';
						END_IF;
				END_IF;
	(*---------------------------------------------------------------------Wait for User Interaction-----------------------------------------------------------------------*)
	9817:
				(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut	:=	FALSE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					(NOT StepActionImPulse)
					THEN
						StepNew			:=	9819;
				END_IF;
	(*----------------------------------------------------------------Move Z axis down 0,5MM----------------------------------------------------------------------------*)
	9819:
				(*Action*)
				IF 	StepActionImPulse
					THEN
						AxisState																:=	STATE_WAIT_NEWOPERATION;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override						:=	100;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	FALSE;		(*Down without Touch Probe :to not affect the touchnumber  *)
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut				:=	ZTouchPosFirstTouchPos	+ 0.5;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut				:=	3;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					NOT StepActionImPulse  AND
					(* status z-axis *)
					( NOT Axis[AxisNo.ZAxis].Status.Disabled ) AND
					Axis[AxisNo.ZAxis].Status.InTargetPosition AND
					Axis[AxisNo.ZAxis].Status.StandStill	AND
					( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut )AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut	:=	FALSE;
						StepNew		:=	9821;
				END_IF;
	(*----------------------------------------------Wait for User Interacton-----------------------------------------------------------------------*)
	9821:		(*Transition*)
				IF	RTrigNextStep.Q  OR
					TestZ
					THEN
						StepNew	:=	9822;
						AaxisRefPosTemp	:=	7 ;
						StartMonitoringAaxis	:=	TRUE;
						StepMotorDestination	:=	AaxisRefPosTemp;
						AaxisActPosition		:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
				END_IF;
	(*----------------------------------------------------------Move A Axis Backward-----------------------------------------------------*)
	9822:
				(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	1;
						IF	(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=7)
							THEN
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	TRUE;;
							ELSE
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	TRUE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;;
						END_IF;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT  StepActionImpulse) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (AaxisRefPosTemp- AaxisTolerenceFast)) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  ( AaxisRefPosTemp + AaxisTolerenceFast))
					THEN
						StepNew				:=		5000;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;
						StartMonitoringAaxis	:=	FALSE;
				END_IF;
	(*---------------------------------------------------------Move Z-Axis to Z-No Touch Position-------------------------------------------*)
	5000:
				(*Transition*)
				IF	RTrigNextStep.Q OR
					TestZ
					THEN
						StepNew		:=	5010;
				END_IF;
	(*----------------------------------------------------------------Move Z-Axis To No touch Position -------------------------------------*)
	5010:		(*Action*)
				IF 	StepActionImPulse
					THEN
						AxisState																:=	STATE_WAIT_NEWOPERATION;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override						:=	100;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut				:=	ZNoTouch;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut				:=	0.25;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					NOT StepActionImPulse  AND
					(* status z-axis *)
					( NOT Axis[AxisNo.ZAxis].Status.Disabled ) AND
					Axis[AxisNo.ZAxis].Status.InTargetPosition AND
					Axis[AxisNo.ZAxis].Status.StandStill	AND
					( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut )AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut	:=	FALSE;
						StepNew		:=	5020;
				END_IF;

				IF 	StepAction AND
					(NOT StepActionImPulse) AND
					(NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe )
					THEN
						IF	( AxisCtrl[AxisNo.ZAxis].Feedback.State.TouchProbe.ActiveAndAxisStopped)
							THEN
								StepNew		:=	6000;;						(*If There is No Touch --&gt; ERROR*)
								MachineCtrl.ProcessControl.Warning.No		:=	EvUnexpectedTouchWithZAxis ;
								MachineCtrl.ProcessControl.Warning.En		:=	TRUE;
								MachineCtrl.Peripheral.Buzzer.Unit.CmdOn	:=	TRUE;
								MachineCtrl.ProcessControl.Warning.Data		:=	'';
						END_IF;
				END_IF;

	(*---------------------------------------------------------------Wait For User Interaction---------------------------------------------------*)
	5020:		(*Transition*)
				IF	RTrigNextStep.Q  OR
					TestZ
					THEN
						StepNew				:=	5030;
						StartMonitoringAaxis	:=	TRUE;
						AaxisActPosition		:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
				END_IF;
	(*-----------------------------------------------------------------Move A-Axis Forward ---------------------------------------*)
	5030:		(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog						:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override						:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog						:=	0.1;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus						:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus						:=	FALSE;;
				END_IF;

				RTrigMonitoringCrash(CLK:=( MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;MonitoringTouchBack) , Q=&gt; );
				(*Transition*)
				IF	MachineCtrl.State.TouchSensor.Machine.IsActuated(*MachineCtrl.State.ChipBreaker.Auto.CrashSignalDetected*)
					THEN
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus						:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus						:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	FALSE;
						AaxisRefPosTemp	:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;		(*First Edge Position*)
						FirstEdgePos			:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
						StepNew				:=	5035;
						StartMonitoringAaxis	:=	FALSE;
						RTrigMonitoringCrash(CLK:= FALSE);
				END_IF;

				(*New Monitoring *)
				IF	RTrigMonitoringCrash.Q AND
					(NOT MachineCtrl.State.TouchSensor.Machine.IsActuated)
					THEN
						StepNew		:=	6000;;						(*If There is No Touch --&gt; ERROR*)
						MachineCtrl.ProcessControl.Warning.No		:=	EvNoTouchSignalDetected;
						MachineCtrl.ProcessControl.Warning.En		:=	TRUE;
						MachineCtrl.Peripheral.Buzzer.Unit.CmdOn	:=	TRUE;
						MachineCtrl.ProcessControl.Warning.Data		:=	'';
				END_IF;
	(*--------------------------------------------------------------------------Wait For User Interaction----------------------------------------------------------------------*)
	5035:		(*Transition*)
				IF	RTrigNextStep.Q OR
					TestZ
					THEN
						StepNew		:=	5040;
						FirstEdgePos	:=	FirstEdgePos	+ 0.3;
						StartMonitoringAaxis	:=	TRUE;
						StepMotorDestination	:=	FirstEdgePos;
						AaxisActPosition		:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
				END_IF;
	(*------------------------------------------------------------------------------Move a-Axis Backwars before To Move Z-Axis Dwn---------------------------------------*)
	5040:		(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	1;
						IF	(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;= FirstEdgePos)
							THEN
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	TRUE;;
							ELSE
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	TRUE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;;
						END_IF;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT  StepActionImpulse) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (FirstEdgePos- AaxisTolerenceFast)) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  ( FirstEdgePos + AaxisTolerenceFast))
					THEN
						StepNew				:=		5045;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;
						StartMonitoringAaxis	:=	FALSE;
				END_IF;
	(*-----------------------------------------------------------------------------Z Dwn-----------------------------------------------------------------------------------------------*)
	5045:
				(*Action*)
				IF 	StepActionImPulse
					THEN
						AxisState																:=	STATE_WAIT_NEWOPERATION;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override						:=	100;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut				:=	ZTouchPosFirstTouchPos 	+ 0.5;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut				:=	2;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					NOT StepActionImPulse  AND
					(* status z-axis *)
					( NOT Axis[AxisNo.ZAxis].Status.Disabled ) AND
					Axis[AxisNo.ZAxis].Status.InTargetPosition AND
					Axis[AxisNo.ZAxis].Status.StandStill	AND
					( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut )AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut	:=	FALSE;
						StepNew		:=	5050;
				END_IF;
	(*--------------------------------------------------------------------------------------------------------------------*)
	5050:		(*---Transition----*)
				IF	RTrigNextStep.Q  OR
					TestZ
					THEN
						StepNew		:=	5060	;
						SecondEdge	:=	AaxisRefPosTemp
										- UI.Order.SawBlade.Width - 0.5(*1*);
						MonitoringTouchFront	:=	AaxisRefPosTemp -
												UI.Order.SawBlade.Width + 0.3 + 0.01;
						StartMonitoringAaxis	:=	TRUE; ;
						StepMotorDestination	:=	SecondEdge;
						AaxisActPosition		:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
				END_IF;
	(*---------------------------------------A-Axis to front Position -------------------------------------------*)
	5060:		(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	1; ;
						IF	(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (SecondEdge))
							THEN
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	TRUE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;;
							ELSE
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	TRUE;;
						END_IF;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT  StepActionImpulse) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (SecondEdge- AaxisTolerenceFast)) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  ( SecondEdge + AaxisTolerenceFast))
					THEN
						StepNew				:=		5070;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;
						StartMonitoringAaxis	:=	FALSE;
				END_IF;
	(*-----------------------------------------------------Wait For User Interaction--------------------------------------------------------*)
	5070:		(*Transition*)
				IF	RTrigNextStep.Q OR
					TestZ
					THEN
						StepNew		:=	5080;
				END_IF;
	(*-------------------------------------------------------Z-Axis To No Touch Position-----------------------------------------------*)
	5080:		(*Transition*)
				IF 	StepActionImPulse
					THEN
						AxisState																:=	STATE_WAIT_NEWOPERATION;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override						:=	100;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	TRUE;		(*Down without Touch Probe :to not affect the touchnumber  *)
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut				:=	ZNoTouch;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut				:=	0.25;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					NOT StepActionImPulse  AND
					(* status z-axis *)
					( NOT Axis[AxisNo.ZAxis].Status.Disabled ) AND
					Axis[AxisNo.ZAxis].Status.InTargetPosition AND
					Axis[AxisNo.ZAxis].Status.StandStill	AND
					( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut )AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut	:=	FALSE;
						StepNew		:=	5090;
				END_IF;

				(*Error Monitoring*)
				IF 	StepAction AND
					(NOT StepActionImPulse) AND
					(NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe )
					THEN
						IF	( AxisCtrl[AxisNo.ZAxis].Feedback.State.TouchProbe.ActiveAndAxisStopped)
							THEN
								StepNew		:=	6000;;						(*If There is No Touch --&gt; ERROR*)
								MachineCtrl.ProcessControl.Warning.No		:=	EvUnexpectedTouchWithZAxis;
								MachineCtrl.ProcessControl.Warning.En		:=	TRUE;
								MachineCtrl.Peripheral.Buzzer.Unit.CmdOn	:=	TRUE;
								MachineCtrl.ProcessControl.Warning.Data		:=	'';
						END_IF;
				END_IF;

	(*----------------------------------------------------Wait For User Interaction--------------------------------------------------------*)
	5090:		(*Transition*)
				IF	RTrigNextStep.Q OR
					TestZ
					THEN
						StepNew	:=	5100;		(*Move A-Axis Backward till touch with the SB*)
						StartMonitoringAaxis	:=	TRUE;
				END_IF;
	(*----------------------------------------Move A-Axis Backward till touch with the SB-----------------------------------------*)
	5100:		(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog						:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override						:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog						:=	0.1;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus						:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus						:=	TRUE;;
					(*	StartMonitoringAaxis	:=	FALSE;*)
				END_IF;

				RTrigMonitoringCrash(CLK:= MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=
																					 MonitoringTouchFront , Q=&gt; );
				(*Transition*)
				IF	MachineCtrl.State.TouchSensor.Machine.IsActuated (*MachineCtrl.State.ChipBreaker.Auto.CrashSignalDetected*)
					THEN
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus						:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus						:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	FALSE;
						SecondEdge			:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
						StepNew				:=	5110;
						StartMonitoringAaxis	:=	FALSE;
						RTrigMonitoringCrash(CLK:= FALSE);
				END_IF;

				IF	RTrigMonitoringCrash.Q(* AND
					(NOT MachineCtrl.State.TouchSensor.Machine.IsActuated)  *)
					THEN
						StepNew		:=	6000;;						(*If There is No Touch --&gt; ERROR*)
						MachineCtrl.ProcessControl.Warning.No		:=	EvNoTouchSignalDetected;
						MachineCtrl.ProcessControl.Warning.En		:=	TRUE;
						MachineCtrl.Peripheral.Buzzer.Unit.CmdOn	:=	TRUE;
						MachineCtrl.ProcessControl.Warning.Data		:=	'';
				END_IF;

	(*----------------------------------------------Wait for User Interaction---------------------------------*)
	5110:		(*Transition*)
				IF	RTrigNextStep.Q OR
					TestZ
					THEN
						StepNew	:=	5120;	(*A-Axis Forward 1 MM*)
						StartMonitoringAaxis	:=	TRUE;
						StepMotorDestination	:=	SecondEdge-1;
						AaxisActPosition		:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
				END_IF;
	(*------------------------------------------------A-Axis Forward -------------------------------------------*)
	5120:		(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	1;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT  StepActionImpulse) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (SecondEdge-1 - AaxisTolerenceFast)) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  ( SecondEdge -1 + AaxisTolerenceFast))
					THEN
						StepNew				:=		5130;		(*Z-Axis Moving Dwn*)
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;
						StartMonitoringAaxis	:=	FALSE;
				END_IF;
	(*------------------------------------Wait For User Interaction-----------------------------------*)
	5130:		(*Transition*)
				IF	RTrigNextStep.Q OR
					TestZ
					THEN
						StepNew		:=5140;
				END_IF;
	(*------------------------------------------------------------------Z-Axis Dwn 1 MM--------------------------*)
	5140:		(*Action*)
				IF 	StepActionImPulse
					THEN
						AxisState																:=	STATE_WAIT_NEWOPERATION;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override						:=	100;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut				:=	ZTouchPosFirstTouchPos   	+ 0.5;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut				:=	2;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					NOT StepActionImPulse  AND
					(* status z-axis *)
					( NOT Axis[AxisNo.ZAxis].Status.Disabled ) AND
					Axis[AxisNo.ZAxis].Status.InTargetPosition AND
					Axis[AxisNo.ZAxis].Status.StandStill	AND
					( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut )AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut	:=	FALSE;
						StepNew		:=	5150;
				END_IF;
	(*-------------------------------------Wait For User Interaction---------------------------------------*)
	5150:		(*Action*)
				IF	RTrigNextStep.Q OR
					TestZ
					THEN
						StepNew		:=	9830;
				END_IF;


	(*############################Stop During Touching Process###############*)
	6000:
				IF 	StepActionImPulse
					THEN
						AxisState																:=	STATE_WAIT_NEWOPERATION;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn					:=	TRUE;;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override						:=	100;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut				:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos + 5;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut				:=	2;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					NOT StepActionImPulse  AND
					(* status z-axis *)
					( NOT Axis[AxisNo.ZAxis].Status.Disabled ) AND
					Axis[AxisNo.ZAxis].Status.InTargetPosition AND
					Axis[AxisNo.ZAxis].Status.StandStill	AND
					( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut )AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut	:=	FALSE;
						StepNew		:=	6005;
				END_IF
	(*-------------------------------------------------------------------Release clamping----------------------------------------------------------------*)
	6005:
		(*Action*)
			IF	StepActionImPulse AND
				(NOT MachineCtrl.State.ChipBreaker.Auto.Clamping.IsReleased)
				THEN
					MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdClose	:=	FALSE;
					MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdOpen	:=	TRUE;
			END_IF;

			(* transition:  *)
			IF	StepAction AND
				(NOT StepActionImPulse) AND
				MachineCtrl.State.ChipBreaker.Auto.Clamping.IsReleased
			THEN
					StepNew	:= 	27000;					(*Z Axis  down*)
			END_IF;

	(*##############################################Error Out###############################################*)
	27000:
				(*Action*)
				IF	 StepActionImPulse
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn			:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus			:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus			:=	FALSE;		(*Stop Moving   A-Axis*)
						ErrorOut			:=	TRUE;
				END_IF;
				(*Transition*)

				IF 	StepAction AND
					(NOT StepActionImPulse)
					THEN
							StepNew		:=	0;
							ErrorOut		:=	FALSE;
				END_IF;
	(*####################################################################*)

	(*---------------------------------------Check The Notch Position--------------------------------------*)
	9900:
				(*Transition*)
				IF	NOT StepActionImPulse  AND
					StepAction
					THEN
						IF	 (TriesNumber&gt;0) AND
							(NOT AaxisStepPositionIsReached)
							THEN
								StepNew				:=	982;(*Move Forward*)
								AaxisRefPosTemp	:= 	MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
							END_IF;
							IF	AaxisStepPositionIsReached
							THEN
								AaxisRefPosTemp	:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
								StepNew				:=	9830;
						END_IF;
				END_IF;
	(*-----------------------------------------------Check the Notch position----------------------------------*)
	9823:
				(*Transition*)
				IF	NOT StepActionImPulse  AND
					StepAction
					THEN
						IF	 (TriesNumber&gt;0) AND
							(NOT AaxisStepPositionIsReached)
							THEN
								StepNew				:=	9825;(*Move Backward*)
								AaxisActPosition		:=	MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
						END_IF;
						IF	AaxisStepPositionIsReached
							THEN
								StepNew				:=	9830;
								AaxisRefPosTemp	:= MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
						END_IF;
				END_IF;
	(*------------------------------------------------Wait for User  Interaction------------ -----------------------*)
	9825:		(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	982;		(* *)
						NextStepPulse	:=	FALSE;
				END_IF;
	(*------------------------------------------------------------------------------------------------------------------*)
	9830:		(* Transition *)
				IF	StepAction
					THEN
						AFrontPos			:=     	SecondEdge + MarginFrontValue + ChipBreakerAutoGWwidth    		     ;
						ARearPos			:=      AaxisRefPosTemp	 - MarginRearValue - ChipBreakerAutoGWwidth     ;
						stTimeStartM			:=	stTimeStruct;
						StartWriting			:=	TRUE;
						StepNew				:=	985;
						StartMonitoringAaxis	:=	TRUE;
						StepMotorDestination	:=	AFrontPos;
						AaxisActPosition		:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
				END_IF;
	(*---------------------------------------------------------Move  A-Axis to Reference Position-------------------------------------------------------------------*)
	982:
				(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	0.5;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;;
						IF	(TriesNumber &gt;0)
							THEN
								AaxisRefPosTemp	:=	MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos + 0.05;
						END_IF ;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT  StepActionImpulse) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (AaxisRefPosTemp- AaxisTolerenceSlow)) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  ( AaxisRefPosTemp + AaxisTolerenceSlow))
					THEN
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;;
						StepNew			:=	983;
						StartWaitAaxis	:=	FALSE;;
				END_IF;
	(*---------------------------------------------------------Wait before moving the stepper--------------------------------------------------------------*)
	983:			(*Transition*)
				WaitForAaxis(IN:=	StartWaitAaxis , PT:=TIME#2s , Q=&gt; , ET=&gt; );
				IF	TRUE
					THEN
						StepNew			:=	9810;
						StartWaitAaxis	:=	FALSE;
				END_IF;
	(*---------------------------------------------Moving the stepper to Reference position-0,2MM ------------------------------------------------*)
	9882:		(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	0.5;
						IF	(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (AaxisRefPosTemp))
							THEN
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	TRUE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;;
							ELSE
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	TRUE;;
						END_IF;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT  StepActionImpulse) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (AaxisRefPosTemp- AaxisTolerenceSlow)) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  ( AaxisRefPosTemp + AaxisTolerenceSlow))
					THEN
						StepNew				:=	9810;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;;
						StartMonitoringAaxis	:=	FALSE;
				END_IF;
	(*-------------------------Move the A-Axis with a high velocity till it reaches the 80% of destination-----------------------*)
	9850:
				(*Action*)
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	1;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;
						StartMonitoringAaxis												:=	TRUE;
					END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT  StepActionImpulse) AND
					(NOT AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdMoveAbsolut) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (AFront80 - AaxisTolerenceSlow)) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  (AFront80 + AaxisTolerenceSlow))
					THEN
						StepNew		:=	985;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
				END_IF;
	(*----------------------------------------------Move A-Axis to the calculated Front position-------------------------------------*)
	985	:			(*Action*)
					IF 	StepActionImpulse
						THEN
							AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
							AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
							AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	1;
							IF	(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos&lt;= AFrontPos)
								THEN
									AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus		:=	FALSE;
									AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus		:=	TRUE;
								ELSE
									AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus		:=	TRUE;
									AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus		:=	FALSE;
							END_IF;
					END_IF;
					(*Transition*)
					IF 	StepAction AND
						(NOT  StepActionImpulse) AND
						(NOT AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdMoveAbsolut) AND

						(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (AFrontPos - AaxisTolerenceFast)) AND
						(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  (AFrontPos + AaxisTolerenceFast))
					THEN
						StepNew				:=	 12200;
						NumberTouch		:=	0;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus		:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus		:=	FALSE;
						StartMonitoringAaxis	:=	FALSE;
					END_IF;
	(*----------------------------------------------Calclation of the start position of X-Axis and Z-Axis------------------------------------*)
	12200:			(*Transition*)
					IF 	StepAction AND
						(NOT StepActionImpulse)
						THEN
							ZAxisStartPosition													:=	ZTouchPosFirstTouchPos +0.7;
							XAxisStartPosition													:=	Axis[AxisNo.XAxis].NcToPlc.ActPos;
							XAxisEndPos														:=	Axis[AxisNo.XAxis].NcToPlc.ActPos  + 360;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;										(*End Moving Up of Z-Axis*)
							StepNew															:=	12450;
					END_IF;
	(*-------------------------------------------------------------Wait For User Interaction------------------------------------------------------*)
	12450:
					(*Transition*)
					IF	RTrigNextStep.Q OR
						ContinousMode
						THEN
							StepNew		:=	1280;		(*Move Axis X&amp;Z To Start position*)
					END_IF;
END_CASE;
</xhtml>
              </ST>
            </body>
            <addData>
              <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
                <ObjectId>5770a76c-d671-4cc6-a170-d5a7657850c8</ObjectId>
              </data>
            </addData>
          </action>
          <action name="ACT_TIME">
            <body>
              <ST>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">fbGetTime(	NETID		:= 	'',			(* Beckhoff Rechner '10.22.2.7.1.1' mit eingestellter Zeit, anstatt Maschinen-PC *)
			START		:= 	( NOT fbGetTime.BUSY ) AND ( NOT fbGetTime.START ),
			TMOUT		:= 	DEFAULT_ADS_TIMEOUT,
			BUSY		=&gt;	 ,
			ERR		=&gt; 	,
			ERRID		=&gt;	,
			TIMESTR	=&gt; 	stTimestruct );</xhtml>
              </ST>
            </body>
            <addData>
              <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
                <ObjectId>43d769c7-4fd6-40fe-a336-0d3a3ff4e30c</ObjectId>
              </data>
            </addData>
          </action>
        </actions>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">
	(* ---------------------------------------------------------------------------- SFC CHIPBREAKER AUTO -------------------------------------------------------------------------- *)

	(* call sfc functionblock *)
	SfcChipBreakerAuto(
						StepNew			:=	StepNew ,
						Reset			:=	Reset ,
						Step			=&gt;	ActualStep ,
						StepAction		=&gt;	StepAction ,
						StepActionImPulse=&gt;	StepActionImPulse			 );


	TestZ			:=	TRUE;

	ContinousMode      := 	TRUE; 	   ;	(*TRUE; ;*)


	(*Reset the Sfc Variables*)
	IF	Reset
		THEN
			CbaSpindleLowSpeed														:=	FALSE;
			CbaSpindleLowSpeedOutput												:=	FALSE;
			StepNew																	:= 	0;
			Done																	:=	FALSE;
			ErrorOut																	:=	FALSE;
			ErrorID																	:=	0;
			StopChipBreaker															:=	FALSE;
			ZaxisCbaLimit															:=	FALSE;
			CBAutoNotPossibleWithTooLargeSbDiameter									:=	FALSE;
			MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn						:=	FALSE;
			MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.IsDeactivated		:=	FALSE;
			WarningAaxis																:=	FALSE;
			WarningAaxisIsSlow														:=	FALSE;
			MachineCtrl.ProcessControl.Warning.No										:=	0;
			StartTimeCounting															:=	FALSE;
			RTrigMonitoringCrash(CLK:=FALSE);
			MachineCtrl.State.ChipBreaker.Auto.GrindingWheelIsReady						:=	FALSE;
	END_IF;

			ChipBreakerAutoGWwidth			:=		UI.MachineSpecification.PeripheralOptional.ChipBreaker.GrindingWheel.Width.Nominal;

			AaxisTolerenceSlow				:=		0.01;
			AaxisTolerenceFast				:=		0.03;

			(*Edge distance  from ui*)


			MarginRearValue					:= 	UI.Order.Job[UI.State.ActualValues.ActualJobNumber.Maximal -1].EdgeDistance.EdgeDistanceRear;
			MarginFrontValue					:= 	UI.Order.Job[UI.State.ActualValues.ActualJobNumber.Maximal -1].EdgeDistance.EdgeDistanceFront;;


	(*###############################################A-Stepper Monitoring###############################################*)
			IF	(AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog &lt;&gt; 0)
				THEN
					IF	(StepNew &lt;&gt; 5030) AND
						(StepNew &lt;&gt; 5090)AND
						(StepNew &lt;&gt; 5100)
						THEN
							StepMotorNeededTimeToMove		:=
																		LREAL_TO_TIME(( ABS( AaxisActPosition -
																						StepMotorDestination ) /
																						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog) );
																	;
						ELSE
							StepMotorNeededTimeToMove		:=	TIME#0.1s;
					END_IF;
				ELSE
					StepMotorNeededTimeToMove		:=	TIME#0.1s;
			END_IF;

			TonMonitoringAaxis(IN:= StartMonitoringAaxis , PT:= (StepMotorNeededTimeToMove*1000)+TIME#4s , Q=&gt; , ET=&gt; );


			RtrigAaxisIsTooSlow(CLK	:=	TonMonitoringAaxis.Q  , Q=&gt; );

	(*Generate an error if the A-Axis is slow or not moving*)

	IF	RtrigAaxisIsTooSlow.Q
		THEN
			StepNew					:=	31000;
			TonMonitoringAaxis(  IN	:=	FALSE);
			RtrigAaxisIsTooSlow(CLK	:=	FALSE);
			StartMonitoringAaxis		:=	FALSE;
			WarningAaxis				:=	TRUE;
	END_IF;

	(*############################################A-Stepper Monitoring End##############################################*)

			StartButton(CLK:= MachineCtrl.Peripheral.ExternalControl.StartSwitch , Q=&gt; );

		(*Manual Positionning*)

			ManPosActive	:=	MachineCtrl.Peripheral.ChipBreaker.Auto.PositionningMode.ManualPositionningIsActive;


		(*---------Software Limit--------------*)

			R_TRIG_ZlimitPos	(CLK :=	ZAxisLimitPos , Q=&gt; );


		(*Controlling Z-Axis Limit Position*)
		IF	R_TRIG_ZlimitPos.Q
			THEN
				StepNew		:=	31000;
				CbaLimit		:=	TRUE;
		END_IF;

		(*Stop Button *)

		Stop_Manual_Pos(CLK:=	 (NOT PauseSwitchActive) , Q=&gt; );

		FTRIG_STOP(CLK	:=	 (NOT PauseSwitchActive) ,
								   Q		=&gt;		 );

		(*Z-Axis Confirm Touch Pos*)
		RTrigConfirmTouchposZ(CLK	:=	MachineCtrl.Peripheral.ExternalControl.ConfirmTouchpos	 , Q=&gt; );

		(*X-Axis Confirm Touch Pos*)
		RTrigConfirmTouchposX(CLK	:= 	MachineCtrl.Peripheral.ExternalControl.ConfirmTouchpos, 	Q=&gt; );


		IF	(StepNew	= 9815)
			THEN
				StartTimeCounting		:=	TRUE;
		END_IF;


	TonCounting(IN:= StartTimeCounting , PT:=TIME#180s , Q=&gt; , ET=&gt; );

		IF	(StepNew	= 985)
			THEN
				StartTimeCounting		:=	FALSE;
				DurationAaxisMotion	:=	TonCounting.ET;
		END_IF;


		(* r_trig next step *)
		RTrigNextStep( CLK := KeyNextStep );
		(* no confirm *)
		(*ContinousMode := FALSE;*)

;
	(*------------------------------------------Pause Requeted---------------------------------------*)

IF	(SfcChipBreakerAuto.Step	&lt;=	1350) AND
	(SfcChipBreakerAuto.Step	&gt;=	1300) AND
		(* pause switch is pressed *)
	(NOT PauseSwitchActive)
		THEN
			PauseRequested		:=	TRUE;
	END_IF;


IF	(SfcChipBreakerAuto.Step	= 9815)
	THEN
		IF	FTRIG_STOP.Q
		THEN
			StepNew		:=	31000;				(*Stop Routine *)
	END_IF;
END_IF;


IF	((SfcChipBreakerAuto.Step	&gt;	1350) OR
	(SfcChipBreakerAuto.Step	&lt;	1300))  AND(*OR*)
	( (SfcChipBreakerAuto.Step	&lt;	90) OR
	(SfcChipBreakerAuto.Step	&gt;	170))
	THEN
		IF	FTRIG_STOP.Q
			THEN
				StepNew		:=	31000;				(*Stop Routine *)
		END_IF;
END_IF;


IF	(SfcChipBreakerAuto.Step &gt;=90)  AND
	(SfcChipBreakerAuto.Step &lt;=170) AND
	Stop_Manual_Pos.Q
	THEN

				StepNew		:=	31600;				(*Direct Stop*)
END_IF;

	(*---------------------------------------ERROR------------------------------------------*)
	(*Error*)
	IF	(ChipBreakerFr AND
		ChipBreakerRe) OR
		( CbaPneumatic AND
		 Stepper)
		THEN
			StepNew		:=	25000;		(*Error*)
	END_IF;

	(* --------------------------------------sfc Reset----------------------------------------- *)

	IF	Reset
		THEN
			StepNew																	:= 	0;
			Done																	:=	FALSE;
			ErrorOut																	:=	FALSE;
			ErrorID																	:=	0;
			StopChipBreaker															:=	FALSE;
			ZaxisCbaLimit															:=	FALSE;
			CBAutoNotPossibleWithTooLargeSbDiameter									:=	FALSE;
			MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn						:=	FALSE;
			MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.IsDeactivated		:=	FALSE;
			WarningAaxis																:=	FALSE;
			AaxisStepPositionIsReached												:=	FALSE;
			StartWaitAaxis															:=	FALSE;
			ZNoTouch																:=	0;
			 MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.ErrorOccured 		:=	FALSE;
			RTrigMonitoringCrash(CLK:=FALSE);
			MachineCtrl.State.ChipBreaker.Auto.GrindingWheelIsReady						:=	FALSE;
	END_IF;






	(*Test low speed warning and instead error*)

	RtrigSpindleLowSpeedError(CLK:= MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.ErrorOccured , Q=&gt; );

	IF	RtrigSpindleLowSpeedError.Q
		THEN
			 StepNew			:=	31000;
			CbaSpindleLowSpeed	:=	 TRUE;
	END_IF;



	ZAxisLimitPos		:=	(Axis[AxisNo.ZAxis].NcToPlc.ActPos &lt;=  (UI.Order.SawBladeHolder.SawBladeLimitation[SBHChipBreakerAutoProtectionIndex].SawBladeDiameter.Minimal)) AND
							(StepNew &gt;=85);

	(*---------------------------------------- pause------------------------------------------- *)

	IF	(SfcChipBreakerAuto.Step	&lt;=	1350) AND
		(SfcChipBreakerAuto.Step	&gt;=	1300)
		THEN
		IF	PauseAvailable AND
			(* pause switch is pressed *)
			(NOT PauseSwitchActive)
			THEN
				PauseRequested			:=	TRUE;
		END_IF;
	END_IF;



	CASE	SfcChipBreakerAuto.Step	OF

		(*------------------------------------------------------------------------ init Step - Reset all------------------------------------------------------------------------  *)
	0	:		(* action: predefine values *)
					CBAutoNotPossibleWithTooLargeSbDiameter							:=	FALSE;
					IF	StepActionImPulse
						THEN
							(* set axis state for check *)
								AxisState	:=	STATE_DISABLED;

							(* Reset x-axis *)
								AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn				:=	FALSE;
								AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut			:=	FALSE;
								AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdCamming				:=	FALSE;

							(* Reset Z-axis *)
								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn				:=	FALSE;
								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut			:=	FALSE;
								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming				:=	FALSE;
							(*Reset A-Axis*)
								AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdPowerOn				:=	FALSE;
								AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdMoveAbsolut			:=	FALSE;
								AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdCamming				:=	FALSE;
								AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog					:=	FALSE;

								MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn					:=	FALSE;
								CBAutoNotPossibleWithTooLargeSbDiameter								:=	FALSE;
								MachineCtrl.State.ChipBreaker.Auto.PauseIsActive							:=	FALSE;
								MachineCtrl.Peripheral.ExternalControl.StatusLedOnTouch1					:=	FALSE;
								MachineCtrl.Peripheral.ExternalControl.StatusLedOnTouch2					:=	FALSE;

								MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.IsDeactivated	:=	FALSE;
								 MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.ErrorOccured 	:=	FALSE;

								Done						:=	FALSE;
								ErrorOut						:=	FALSE;
								ErrorID						:=	0;
								ActualTeeth					:=	0;
								Paused						:=	FALSE;
								PauseStep					:=	0;
								PauseAvailable				:=	FALSE;
								PauseRequest				:=	FALSE;
								PauseRequested				:=	FALSE;
								WorkingStepNo				:=	1;
								CammingActive				:=	FALSE;
								NumberTouch				:=	0;
								Delta						:=	0;
								NumberRevolution			:=	0;
								SimpleTouch					:=	FALSE;				(*OnlyOne Touch*)
								DoubleTouch					:=	FALSE;				(*We Requie 2 Touchs*)
								ErrorOut						:=	FALSE;
								NumberTouch				:=	0;
								ActualRevolutions				:=	0;
								StopChipBreaker				:=	FALSE;
								KeyNextStep					:=	FALSE;
								(*Positionning Type*)
								ManPosActive				:=	FALSE;
								(* status led touching *)
								CbaSpindleLowSpeed			:=	FALSE;
								CbaSpindleLowSpeedOutput	:=	FALSE;
								StopChipBreaker				:=	FALSE;
								CbaLimit						:=	FALSE;
								ZaxisCbaLimit				:=	FALSE;
								WarningAaxis					:=	FALSE;
								WarningAaxisIsSlow			:=	FALSE;
								StartMonitoringAaxis			:=	FALSE;
								StartMovingStepByStepRear	:=	FALSE;
								StartMovingStepByStepFront	:=	FALSE;
								TriesNumber					:=	0;
								AaxisStepPositionIsReached	:=	FALSE;
								StartWaitAaxis				:=	FALSE;
								ZNoTouch					:=	0;
								ZposForCsv					:=	0;
								StartWriting					:=	FALSE;
								RTrigMonitoringCrash(CLK:=FALSE);
								TestCW						:=	FALSE;
								TestCCW					:=	FALSE;
					END_IF;

					(* transition *)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						(* stop switch not pressed *)
							PauseSwitchActive
						THEN
							StepNew	:= 10;									(* -&gt; wait for Start *)
					END_IF;
		(*-------------------------------------------------------------  wait for Start----------------------------------------------------------------- *)
	10	:
					(* transition:  *)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						(* recut/resharp only in automatic mode *)
							AutomaticMode AND
						(* Start sfc from external *)
							Start AND
						(* machine door is closed *)
							MachineStateSharpenerDoorIsClosed AND
						(* safe state are disabled *)
							(NOT MachineStateSafetyStateActive) AND
						 (* stop switch not pressed *)
							(PauseSwitchActive)
						THEN
							StepNew									:= 	20;									(* -&gt; Enable X-axis ,Z-axis and A -Axis*)
							ChipBreakerFr							:=	TRUE;
							ChipBreakerRe							:=	FALSE;
							StopChipBreaker							:=	FALSE;
							KeyNextStep								:=	FALSE;
							ErrorOut									:=	FALSE;
							ZaxisCbaLimit							:=	FALSE;
							CBAutoNotPossibleWithTooLargeSbDiameter	:=	FALSE;
							AaxisRefPosTemp						:=	UI.MachineSpecification.PeripheralOptional.ChipBreaker.Notch.SBEdgeOffset;			(*Reference Value of the A-Axis*)
							AaxisReferenceValue						:=	AaxisRefPosTemp;
							AaxisStepPositionIsReached				:=	FALSE;
							StartWaitAaxis							:=	FALSE;
							ZNoTouch								:=	0;
							StartWriting								:=	FALSE;
							 MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.ErrorOccured 	:=	FALSE;
							MachineCtrl.State.ChipBreaker.Auto.GrindingWheelIsReady					:=	FALSE;
					END_IF;

		(*------------------------------------------------------------Wait For User Interaction--------------------------------------------------------------*)
	20:			IF	StepActionImpulse
					THEN
						NextStepPulse		:=	TRUE;
					END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew				:= 	22;
						NextStepPulse		:=	FALSE;
						ErrorOut				:=	FALSE;
				END_IF;

		(*---------------------------------------------------------------- action: Enable x +z+a Axis-----------------------------------------------------------*)
	22	:		(*Action*)
					ErrorOut					:=	FALSE;
					IF	StepActionImPulse
						THEN
							(* set axis state for check *)
								AxisState	:=	STATE_WAIT_NEWOPERATION;
							(* x-axis - Enable *)
								AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
								AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
								AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdCamming			:=	FALSE;
								AxisCtrl[AxisNo.XAxis].Command.ExternalControl.override				:=	100;
							(* Z-axis - Enable *)
								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
								AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override				:=	100;
							(* Axis Is Used--&gt; Axis Enable*)
								IF	Stepper
									THEN
							(*A-Axis- Enable*)
								AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
								AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
								AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdCamming			:=	FALSE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.override				:=	100;
								END_IF;
						END_IF;

					(* transition: axis are Enabled? *)
					IF	StepAction AND
						(NOT StepActionImPulse)
						THEN
							IF	Stepper
								THEN
						(* recut/resharp only in automatic mode *)
								IF	AutomaticMode AND
								(* status x-axis *)
									(NOT Axis[AxisNo.XAxis].Status.Disabled) AND
									Axis[AxisNo.XAxis].Status.StandStill AND
									( AxisCtrl[AxisNo.XAxis].feedback.state.ActualFbState = AxisState ) AND
								(* status Z-axis *)
									(NOT Axis[AxisNo.ZAxis].Status.Disabled) AND
									Axis[AxisNo.ZAxis].Status.StandStill AND
									( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState ) AND
								(*Status A-Axis*)
									(NOT Axis[AxisNo.AAxis].Status.Disabled) AND
									Axis[AxisNo.AAxis].Status.StandStill AND
									( AxisCtrl[AxisNo.AAxis].feedback.state.ActualFbState = AxisState )AND
								(* stop switch not pressed *)
									(PauseSwitchActive)
									THEN
									StepNew	:= 	25;
								END_IF;
							ELSIF	CbaPneumatic
									THEN
										IF	AutomaticMode AND
											(* status x-axis *)
												(NOT Axis[AxisNo.XAxis].Status.Disabled) AND
												Axis[AxisNo.XAxis].Status.StandStill AND
												( AxisCtrl[AxisNo.XAxis].feedback.state.ActualFbState = AxisState ) AND
											(* status Z-axis *)
												(NOT Axis[AxisNo.ZAxis].Status.Disabled) AND
												Axis[AxisNo.ZAxis].Status.StandStill AND
												( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState ) AND
											(* stop switch not pressed *)
												(PauseSwitchActive)
												THEN
													StepNew		:=	25;	(*Wait for user Interaction*)
										END_IF;
							END_IF;
					END_IF;

(* ---------------------------------- wait for user interaction  ------------------------------------------- *)
	25:			IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	26;(*27*)
						ChipBreakerFr	:=	TRUE;
						ChipBreakerRe	:=	FALSE;
						NextStepPulse	:=	FALSE;
						ActualTeeth		:=	0;
						NumberTouch	:=	0;
						ErrorOut			:=	FALSE;
						StopChipBreaker	:=	FALSE;
						KeyNextStep		:=	FALSE;
				END_IF;

	(*--------------------------------------------Check Coolant Pump----------------------------------------------------------*)

	26:			(*Action*)
				IF	StepActionImPulse AND
					MachineCtrl.state.CoolantPump.unit.IsActive
					THEN
						MachineCtrl.Peripheral.CoolantPump.auto.CmdOn	:=	FALSE;
						MachineCtrl.Peripheral.CoolantPump.auto.CmdOff	:=	TRUE;
				END_IF;
		
				(* transition: coolant pump is disabled? *)
				IF	StepAction AND
					( NOT StepActionImPulse )
					THEN
						StepNew		:=	27;
				END_IF;

	(* ----------------------------------------------- move y-axis to position 0 : Ref--------------------------------------- *)
	27	:	(* action: move y-axis to position 0 *)
				IF	StepActionImPulse
					THEN
						(* y-axis *)
							AxisState														:=	STATE_WAIT_NEWOPERATION;
							AxisCtrl[AxisNo.YAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
							AxisCtrl[AxisNo.YAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
							AxisCtrl[AxisNo.YAxis].Command.NominalValue.VeloMoveAbsolut		:=	30;			(*  mm / second *)
							AxisCtrl[AxisNo.YAxis].Command.NominalValue.PositionMoveAbsolut		:=	0;
							AxisCtrl[AxisNo.YAxis].Command.ExternalControl.Override				:=	100;
				END_IF;

				TON_Wait(IN:=		StepAction	AND
									(NOT StepActionImPulse) AND
									(* status y-axis *)
									Axis[AxisNo.YAxis].Status.StandStill AND
									Axis[AxisNo.YAxis].Status.InTargetPosition AND
									( AxisCtrl[AxisNo.YAxis].feedback.state.ActualFbState = AxisState ) AND
									( NOT AxisCtrl[AxisNo.YAxis].Command.OperationMode.CmdMoveAbsolut )		 ,
									 PT:=	TIME#3S
									 , Q=&gt; , ET=&gt; );
				(*Transition*)
				IF	StepAction	AND
					(NOT StepActionImPulse) AND
					(* status y-axis *)
					Axis[AxisNo.YAxis].Status.InTargetPosition AND
					( AxisCtrl[AxisNo.YAxis].feedback.state.ActualFbState = AxisState ) AND
					( NOT AxisCtrl[AxisNo.YAxis].Command.OperationMode.CmdMoveAbsolut )
					THEN
					StepNew		:=	28;
					AxisCtrl[AxisNo.YAxis].Command.OperationMode.CmdPowerOn			:=	FALSE;
					AxisCtrl[AxisNo.YAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
				END_IF;
	(*-------------------------------------------------------Check Grinding Head Position---------------------------------------------------*)

	28:			(* action: grinding head to middle position *)
					IF	StepActionImPulse AND
						(* Grinding Head Not in Middle *)
						 ( NOT MachineCtrl.state.GrindingHead.Unit.IsInMiddlePosition )
						THEN
							MachineCtrl.Peripheral.GrindingHead.unit.auto.CmdMiddlePosition	:=	TRUE;
							MachineCtrl.Peripheral.GrindingHead.KeyLED.CmdMiddlePosition	:=	TRUE;
					END_IF;

					(* transition *)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						(* status grinding head *)
						( MachineCtrl.state.GrindingHead.Unit.IsInMiddlePosition )AND
						( NOT MachineCtrl.Peripheral.GrindingHead.unit.auto.CmdMiddlePosition )
						THEN
							StepNew	:= 29;				(*Check The Grinding Wheel Status*)
					END_IF;
	(*--------------------------------------------------------------Check The Grinding Wheel-----------------------------------------------------*)
	29:				(*Action*)
					IF	StepActionImPulse AND
						MachineCtrl.State.GrindingWheel.Unit.IsActive
						THEN
							MachineCtrl.Peripheral.GrindingWheel.Unit.Auto.CmdOff	:=	TRUE;
							MachineCtrl.Peripheral.GrindingWheel.Unit.Auto.CmdOn	:=	FALSE;
					END_IF;
					(*Transition*)
					IF	StepAction  AND
						(NOT StepActionImPulse)
						THEN
							StepNew		:=	30;
					END_IF;
	(*------------------------------------------------------------Compensation If Necessary-------------------------------------------------------*)

		30:			(*Action*)
					IF	StepActionImPulse
						THEN
							IF	(MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.PreviousPrevious &lt;&gt;MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.Previous)
								THEN
									IF	 (MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.PreviousPrevious = 'ClockWise')
										THEN
											GearPlayXAxisSharpChamfer	:=	UI.MachineSpecification.PeripheralBasic.Axis.X.GearBacklash * -1;
										ELSE
											GearPlayXAxisSharpChamfer	:=	UI.MachineSpecification.PeripheralBasic.Axis.X.GearBacklash ;
									END_IF;
								ELSE
									GearPlayXAxisSharpChamfer			:=	0;
							END_IF;

						IF 	(MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.Previous  &lt;&gt;
																						MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.Actual)
							THEN
								GearPlayXAxis	:=	UI.MachineSpecification.PeripheralBasic.Axis.X.GearBacklash * -1;
							ELSE
								GearPlayXAxis	:=	0;
						END_IF;

						GearPlayXAxis		:=	GearPlayXAxis +
												GearPlayXAxisSharpChamfer		;
					END_IF;

					(*Transition*)
					IF	StepAction AND
						(NOT StepActionImPulse)
						THEN
							StepNew		:=	40;
					END_IF;
	(*################################POSITIONIERUNG MANUELLE################################*)

		40:			(*Action*)
					IF	StepAction AND
						(NOT StepActionImPulse)
						THEN
							IF	ManPosActive
								THEN
									StepNew		:=	50;				(*Manual Positionning *)
								ELSE
									StepNew		:=	42;				(*Auto Positionning*)
							END_IF;
					END_IF;

	(*--------------------------------------------------------------Calc X Pos Depending On Previous Job--------------------------------------------------------*)

		42:			IF	StepAction AND
						(NOT StepActionImPulse)
						THEN
							IF	(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.Recutting) OR
								(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.ReSharpening)
								THEN
										StepNew		:=	45 ;
									ELSIF	(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.Chamfering) OR
											(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.ChamferingAllTeeth)
										THEN
												StepNew		:=	48	;
							END_IF;
					END_IF;

	(*--------------------------------------------------------------Calculation of Touch Position x/z Axis-------------------------------------------------------------*)
		45:			(*Action*)
					IF	StepActionImPulse
						THEN
							Zx			:=	UI.MachineSpecification.PeripheralOptional.ChipBreaker.ZPosCorrectionResharpRecut*2;
							(*degree per tooth calc*)
							IF	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.IsActive
								THEN
									DegPerTeeth			:=	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.LengthDEG;
								ELSE
									DegPerTeeth			:=	360.0 / MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.SawBlade.NumberOfTeeth;
							END_IF;

							(*UpfeedMM calc*)
							ZAxisUpfeedMM		:=	2*(MachineCtrl.ProcessTemp.ActualJobData.Job.Infeed.TotalInfeed + REAL_TO_LREAL( UI.MachineSpecification.PeripheralOptional.ChipBreaker.YOffSet));
							RSS				:=	MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.GrindingWheel.Diameter / 2;
							DSSDiff				:=	200 - MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.GrindingWheel.Diameter;
							WorkingAngle		:=	UI.MachineSpecification.Base.WorkingAngle;
							BSS					:=	ActualGrindingWheel.Layer.Thickness;
							WorkingAngleRAD 	:=	WorkingAngle / 180 * PI;
							YrefPos				:=	YDistanceToTouchPos  -
													UI.MachineSpecification.PeripheralBasic.Axis.Y.Position.HomingOffset;																			(*Ref Point Of Y Axis*)
							YendPos			:=	MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.EndPosActOpMode.PosY_CBA;	(*Y End Position Buffered After The Resharpening Or Retoothing*)

							DeltaZ				:=	2*(YrefPos-YendPos)*COS(WorkingAngleRAD ) + Zx + DSSDiff*COS(WorkingAngleRAD )  ;									(*Z-Axis Corrector : Zx*)
							DeltaX				:=	SIN(WorkingAngleRAD )*(YendPos - YrefPos -100+RSS) + 0.5*(BSS-2);
							DeltaX_DEG			:=	( 360.0 / (ActualSawBlade.Diameter * PI) ) * DeltaX;										(*DeltaX MM2DEG*)

							XoffsetInGrad			:=	( 360.0 / (ActualSawBlade.Diameter * PI) ) * UI.MachineSpecification.PeripheralOptional.ChipBreaker.XOffSet;

							ZPosition			:=
													ActualSawBlade.Diameter +
													 DeltaZ ;

							XPosition			:=	Axis[AxisNo.XAxis].NcToPlc.ActPos + GearPlayXAxis  ;
					END_IF;
					(*Transition: Is The Calcualtion Finished?*)
					IF 	StepAction AND
						(NOT StepActionImPulse)
						THEN
							StepNew		:=	50;				(*MoveX &amp; Z Axis To Definiert  Pos*)
					END_IF;

	(*------------------------------------------------------------------------CBA After Chamfering-----------------------------------------------------------------------------*)

		48:
					(*Action*)
					IF	StepActionImPulse
						THEN
							Zx						:=	UI.MachineSpecification.PeripheralOptional.ChipBreaker.ZPosCorrectionResharpRecut*2;
							(*degree per tooth calc*)
							(*DegPerTeeth				:=	(1/ UINT_TO_LREAL(UI.Order.SawBlade.NumberOfTeeth))  *360; *)

								(*degree per tooth calc*)
							IF	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.IsActive
								THEN
									DegPerTeeth			:=	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.LengthDEG;
								ELSE
									DegPerTeeth			:=	360.0 / MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.SawBlade.NumberOfTeeth;
							END_IF;

							(*UpfeedMM calc*)
							ZAxisUpfeedMM			:=	2*(MachineCtrl.ProcessTemp.ActualJobData.Job.Infeed.TotalInfeed +  REAL_TO_LREAL (UI.MachineSpecification.PeripheralOptional.ChipBreaker.YOffSet));
							RSS					:=	MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.GrindingWheel.Diameter / 2;
							DSSDiff					:=	200 - MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.GrindingWheel.Diameter;
							WorkingAngle			:=	UI.MachineSpecification.Base.WorkingAngle;
							BSS						:=	ActualGrindingWheel.Layer.Thickness;
							WorkingAngleRAD 		:=	WorkingAngle / 180 * PI;
							YrefPos					:=	YDistanceToTouchPos  -
														UI.MachineSpecification.PeripheralBasic.Axis.Y.Position.HomingOffset;																		(*Ref Point Of Y Axis*)
							YendPos				:=	MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.EndPosActOpMode.PosY_CBA;	(*Y End Position Buffered After The Resharpening Or Retoothing*)

							DeltaZ					:=	2*(YrefPos-YendPos)*COS(WorkingAngleRAD ) + Zx + DSSDiff*COS(WorkingAngleRAD ) ;									(*Z-Axis  Corrector : Zx*)
							DeltaX					:=	SIN(WorkingAngleRAD )*(YendPos - YrefPos -100+RSS) + 0.5*(BSS-2);
							DeltaX_DEG				:=	( 360.0 / (ActualSawBlade.Diameter * PI) ) * DeltaX;										(*DeltaX MM2DEG*)
							XoffsetInGrad				:=	( 360.0 / (ActualSawBlade.Diameter * PI) ) * UI.MachineSpecification.PeripheralOptional.ChipBreaker.XOffSet;
														(*IF Previous Job Is Chamfering*)


							ZPosition				:=
														ActualSawBlade.Diameter +
														 DeltaZ ;
						(*----------------------------------------------------------------------------------------------------------------------*)
						IF	MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.Previous = 'CounterClockWise'
								THEN
									(*Position if chamfer is ccw*)
									CalculatedXPosition			:=	MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.EndPosActOpMode.PosX_CBA +
														     		  	(360 *  2 * MachineCtrl.Peripheral.ChipBreaker.Auto.Number_Rev_Chamf.Rev_Chamfering)   + GearPlayXAxis;
								ELSE
									(*Position if chamfer is cw*)
									CalculatedXPosition			:=	MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.EndPosActOpMode.PosX_CBA -
														     			(360 *  2 * MachineCtrl.Peripheral.ChipBreaker.Auto.Number_Rev_Chamf.Rev_Chamfering)  - GearPlayXAxis;
							END_IF;

							(*Difference between Calculated Pos and Actual Pos after chamfering*)
							DiffXactposXcalcPos				:=	ABS (  CalculatedXPosition - MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.EndPosActOpMode.PosX);
							(*convert this difference to number of teeth*)
							NumberOfTeethToAddReal			:= 	(DiffXactposXcalcPos / DegPerTeeth);

							IF  (	LMOD (DiffXactposXcalcPos , DegPerTeeth)   &lt;&gt; 0)
								THEN
									NumberOfTeethToAdd		:=	TRUNC_INT (NumberOfTeethToAddReal )+1;
								ELSE
									NumberOfTeethToAdd		:=	TRUNC_INT (NumberOfTeethToAddReal ) ;
							END_IF;

							(*Value for compensation *)
							rValueToAdd						:=	INT_TO_LREAL(NumberOfTeethToAdd) * DegPerTeeth;

							IF	(CalculatedXPosition &lt;  MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.EndPosActOpMode.PosX) (* Actpos X-Axis *)
								THEN
									XPosition			:=		CalculatedXPosition + rValueToAdd;
								ELSE
									XPosition			:=		CalculatedXPosition - rValueToAdd ;(* + DegPerTeeth - LMOD (DiffXactposXcalcPos , DegPerTeeth ) *) ;
									TestCW	:=	TRUE;

							END_IF;
					END_IF;
					(*Transition: Is The Calcualtion Finished?*)
					IF 	StepAction AND
						(NOT StepActionImPulse)
						THEN
							StepNew		:=	50;							(*MoveX &amp; Z Axis To Definiert  Pos*)
					END_IF;

	(*-------------------------------------------------------Saw Blade Bracket To  Home Pos----------------------------------------------------------------------*)

		50:			(*Action*)
					IF	StepActionImPulse
						THEN
							IF	( NOT MachineCtrl.state.SawBladeBracket.InHomePosition)
								THEN
									MachineCtrl.Peripheral.SawBladeBracket.CmdWorkPos		:=	FALSE;
									MachineCtrl.Peripheral.SawBladeBracket.CmdHomePos	:=	TRUE;
							END_IF;
					END_IF;
					(*Transition is Saw Blade Bracket In Home Position ?*)

					IF StepAction AND
					     (NOT StepActionImPulse) AND
					     (NOT MachineCtrl.Peripheral.SawBladeBracket.CmdHomePos) AND
					      MachineCtrl.state.SawBladeBracket.InHomePosition
					THEN
							IF	ManPosActive
								THEN
									(* man positioning mode -&gt; z-axis to handover pos *)
								(*	ZPosAfterSharpening	:=	UI.MachineSpecification.PeripheralBasic.Axis.Positions.HandOver;;*)
									StepNew				:=	75;
								ELSE
									(* auto positioning mode -&gt; move z-axis down *)
									ZPosAfterSharpening	:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos + 160  ;
									StepNew				:=	60;
							END_IF;

					END_IF;
	(*---------------------------------------------------------------Action Move  To Z Axis Handover Position----------------------------------------------------*)
	60	:			(*Action*)

					IF	 StepActionImPulse
						THEN
							(* Z-axis - move absolute *)
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel 		:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut		:=	100;
							IF	(ZPosAfterSharpening &lt;=  UI.MachineSpecification.PeripheralBasic.Axis.Positions.Homing)  		(*To Avoid Going Deeper than Homing Position Z-Axis*)
								THEN
									AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut		:=	ZPosAfterSharpening;
								ELSE
									CBAutoNotPossibleWithTooLargeSbDiameter		:=	TRUE;
							END_IF;
					END_IF;

					(*Transition : Is Z- Axis In Handover Pos?*)

					IF     	StepAction AND
					   	 (NOT StepActionImPulse) AND
						(Axis[AxisNo.ZAxis].NcToPlc.ActPos	&gt;= ZPosAfterSharpening - 0.1) AND
						(Axis[AxisNo.ZAxis].NcToPlc.ActPos	&lt;= ZPosAfterSharpening +0.1)
						THEN
							StepNew		:=	70;							(*ChipBreaker Swivel Unit To Work Pos*)
					END_IF;

		(*-----------------------------------------------------------------Wait For User Interaction-----------------------------------------------------------------*)

	70:			(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	80;
						NextStepPulse	:=	FALSE;
				END_IF;
                     (*  ----------------------------------------------------------------------------------------------------------------------------------------------------------------*)
	75:
				IF	StepActionImPulse
					THEN
					(* set axis state for check *)
						AxisState	:=	STATE_WAIT_NEWOPERATION;
					(* x-axis - Enable *)
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut		:=	20;
						AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override				:=	100;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut		:=	UI.MachineSpecification.PeripheralBasic.Axis.Positions.Homing;;
				END_IF;
				(*Transition : Is Z- Axis In Reference Pos?*)
				IF     	StepAction AND
				   	 (NOT StepActionImPulse) AND
					  (Axis[AxisNo.ZAxis].NcToPlc.ActPos &gt;= UI.MachineSpecification.PeripheralBasic.Axis.Positions.Homing) AND
					  (NOT Axis[AxisNo.ZAxis].Status.Disabled)
					THEN
						StepNew		:=	80;
				END_IF;


		(*----------------------------------------------------Chip Breaker Swivel Unit  to Work Position------------------------------------------------#6*)
	80	:		(*Action *)
				IF 	StepActionImpulse AND
					(NOT MachineCtrl.State.ChipBreaker.Auto.SwivelUnit.InWorkPosition)
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.SwivelUnit.CmdHomePos	:=	FALSE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.SwivelUnit.CmdWorkPos	:=	TRUE;
				END_IF;

				(*Transition : Is Chip Breaker In Work Position?*)

				IF 	StepAction AND
				   	 (NOT StepActionImPulse) AND
				     	MachineCtrl.State.ChipBreaker.Auto.SwivelUnit.InWorkPosition
					THEN
						StepNew		:=	82;		(*Release Clamping*)
				END_IF;
		(*--------------------------------------------------------------------Release Clamping-----------------------------------------------------------------------*)

	82:			(*Action*)
					IF	StepActionImPulse
						THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdClose	:=	FALSE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdOpen	:=	TRUE;
					END_IF;

					(* transition:  *)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						MachineCtrl.State.ChipBreaker.Auto.Clamping.IsReleased
						THEN
							StepNew	:= 	85;			(*Select The Positionning Mode*)
					END_IF;

		(*----------------------------------------------------------------Wait For User Interaction---------------------------------------------------------------*)

	85:			IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				(*Transition*)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					( NOT MachineCtrl.state.GrindingWheel.unit.IsActive ) AND
					( NOT MachineCtrl.Peripheral.GrindingWheel.unit.auto.CmdOff ) AND
					( NOT MachineCtrl.Peripheral.CoolantPump.auto.CmdOff ) AND
					( NOT MachineCtrl.state.CoolantPump.unit.IsActive )
					THEN
						StepNew			:= 	86;		(* ManPosActive?*)
						NextStepPulse	:=	FALSE;
				END_IF;

		(*----------------------------------------------------------------------ManPosActive?--------------------------------------------------------------------*)

		(*Transition*)
	86:				IF	StepAction AND
						(NOT StepActionImPulse)
						THEN
							IF	ManPosActive
								THEN
									StepNew		:=	90;		(*Axe Deactivieren --&gt; start of manual positionning*)
									ELSE
										StepNew		:=	875	(* Move Z &amp; X Axis To Calculated  Positions*);
							END_IF;
					END_IF;

	(*####################################Manual Positionning#######################################*)


	(*--------------------------------------------------------------------deactivate axis Z&amp;X---------------------------------------------------------------*)

	90:				(* action:   *)
				IF	StepActionImPulse
					THEN
						(* set axis state for check *)
							AxisState	:=	STATE_INIT;
						(* x-axis - disable *)
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn			:=	FALSE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdCamming			:=	FALSE;
						(* z-axis - disable *)
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
				END_IF;
				(* transition:  *)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					(* status x-axis *)
						Axis[AxisNo.XAxis].Status.Disabled AND
						( AxisCtrl[AxisNo.XAxis].feedback.state.ActualFbState = AxisState ) AND
					(* status z-axis *)
						Axis[AxisNo.ZAxis].Status.Disabled AND
						( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						StepNew		:= 	95;			(*Reset X-Axis Act Position*)
					END_IF;

		(* ---------------------------------------------------------- reset x-axis actpos -------------------------------------------------------------- *)
	95	:	(* action:  *)
					IF	StepActionImPulse
						THEN
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdSetEncoderPosition		:=	TRUE;
							AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionSetNewEncoderPos	:=	0;
					END_IF;

					(* transition:  *)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						(NOT AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdSetEncoderPosition)
						THEN
							StepNew								:= 	100;							(* -&gt; Activate safety state *)
					END_IF;
		(*------------------------------------------------------------Activate Safety state----------------------------------------------------------------*)
				(*Action*)

	100:			IF	StepActionImPulse
					THEN
						MachineCtrl.Peripheral.SafetyState.CmdActivate		:=	TRUE;
						MachineCtrl.ProcessControl.Event.En					:=	TRUE;
				END_IF;

				(*Transition*)
				IF	StepAction AND
				(NOT StepActionImPulse) AND
				( NOT MachineCtrl.Peripheral.SafetyState.CmdActivate ) AND
				MachineCtrl.state.SafetyState.unit.IsActive
					THEN
						StepNew	:= 110;								(* -&gt; Message : Open Door*)
				END_IF;

		(* ------------------------------------------------ Message : Open Door&amp;Set Up Mode---------------------------------------------------*)

				(*Action*)
	110:			IF	StepActionImPulse
					THEN
					(* set Event *)
						MachineCtrl.ProcessControl.Event.No			:=	EvNoOpenDoorInitSetUpMode;
						MachineCtrl.ProcessControl.Event.En			:=	TRUE;
						MachineCtrl.ProcessControl.Event.SId		:=	EvEventSourceId;
						MachineCtrl.ProcessControl.Event.Class		:=	TcEventClassMessage;
						MachineCtrl.Peripheral.Buzzer.Unit.CmdOn	:=	TRUE;
				END_IF;
				(* transition:  *)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					MachineCtrl.state.door.sharpener.IsOpen AND
					MachineCtrl.State.Mode.InitSetUp.IsActive
					THEN
						StepNew	:= 121;									(* desable Axis X&amp;Z *)
				END_IF;

			(* ----------------------------------------------------------desable Axis-------------------------------------------------------------------- *)

	121:		(*Action*)
				IF	StepActionImPulse
					THEN
					(* set axis state for check *)
						AxisState	:=	STATE_DISABLED;
					(* Reset x-axis *)
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn			:=	FALSE;
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdCamming			:=	FALSE;

					(* Reset Z-axis *)
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
				END_IF;
				(*Transition*)
				(* status x-axis *)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					( Axis[AxisNo.XAxis].Status.Disabled)  AND
					(* status Z-axis *)
					( Axis[AxisNo.ZAxis].Status.Disabled)
					THEN
						StepNew		:=	123;								(*Deactivate Safety  while the door is open*)
				END_IF;

			(*------------------------------------------------Deactivate Safety  while the door is open--------------------------------------------*)

				(*Action*)
	123:			IF	StepActionImPulse
					THEN
						MachineCtrl.Peripheral.SafetyState.CmdDeactivate	:=	TRUE;
				END_IF;

				(*Wait for a While Before Activating Axis*)
				TONWaitSafetyStatePause( IN  	:=  	StepAction AND
												( NOT MachineCtrl.Peripheral.SafetyState.CmdDeactivate ) AND
												( NOT MachineCtrl.state.SafetyState.unit.IsActive ),
										 PT 	:= 	TIME#20ms);

				StartButton(CLK:= MachineCtrl.Peripheral.ExternalControl.StartSwitch , Q=&gt; );

				(* transition:  *)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					MachineCtrl.state.SafetyState.unit.IsInactive AND
					(NOT MachineCtrl.Peripheral.SafetyState.CmdDeactivate) AND
					TONWaitSafetyStatePause.Q
					THEN
						StepNew		:=130;
				END_IF;
			(*--------------------------------------------------------------Activate Axis X-Z-------------------------------------------------------------*)

				(*Action*)
	130:			IF	StepActionImPulse
					THEN
						(* set axis state for check *)
						AxisState	:=	STATE_WAIT_NEWOPERATION;
						(*X-Axis*)
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn					:=	TRUE;
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogHandwheel 				:=	FALSE;
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogButtonHandWheel		:=	FALSE;
						AxisCtrl[AxisNo.XAxis].Command.NominalValue.VeloJog						:=	ChipBreakerXAxisVelo;		(*XAxisVelo;*)
						AxisCtrl[AxisNo.XAxis].Command.ExternalControl.override						:=	100;

						(*Z-Axis*)

						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn					:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJog						:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel				:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloJog						:=	3;						(* 3 mm / second *)
						AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override						:=	100;
				END_IF;

				(*Transition*)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
				(* operation mode *)
					MachineCtrl.State.Mode.InitSetUp.IsActive AND
				(* status x-axis *)
					(NOT Axis[AxisNo.XAxis].Status.Disabled) AND
					Axis[AxisNo.XAxis].Status.StandStill AND
					( AxisCtrl[AxisNo.XAxis].feedback.state.ActualFbState = AxisState ) AND
				(* status y-axis *)
					(NOT Axis[AxisNo.ZAxis].Status.Disabled) AND
					Axis[AxisNo.ZAxis].Status.StandStill AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						StepNew		:=	135;		(* Move Z-Axis with Handwheel  &amp; X-Axis with Side Buttons*)
					(*Buffer Actual Positions*)
						XPosition	:=	Axis[AxisNo.XAxis].NcToPlc.ActPos;
						ZPosition	:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos;
				END_IF;

			(*-------------------------------------- Move Z-Axis with Handwheel  &amp; X-Axis with Side Keys--------------------------------------------*)
				(*Action*)

	135:			IF	StepActionImPulse
						THEN
							(*----------------------------------------Velocity Calculation------------------------------------------------------*)
						(* calc sawblade circumference *)
							SBCircumference				:=	ActualSawBlade.Diameter*PI;
							(* max feedrate chip breaker  *)
							ChipBreakerAutoXAxisMaxVelo	:=	5.0;
						(* calc velo x-axis degree/s *)
							ChipBreakerAutoVeloTemp		:=	( 360.0 * ChipBreakerAutoXAxisMaxVelo ) / SBCircumference;
							ChipBreakerXAxisVelo			:=	ChipBreakerAutoVeloTemp	;
							(*---------------------------------------------------------------------------------------------------------------------------*)

							(* X-axis *)
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogHandwheel				:=	FALSE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogButtonHandWheel		:=	TRUE;
							AxisCtrl[AxisNo.XAxis].Command.NominalValue.VeloJog						:=	ChipBreakerXAxisVelo;
							(*Z-Axis*)
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJog						:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel				:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloJog						:=	3;			(* 3 mm / second *)
							AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.ExternalEncoderNumber			:=	AxisNo.ZAxisExtENC100.ExtEncNo;
							AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.ExternalEncoderRatioNumerator	:=	18;
							AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.ExternalEncoderRatioDenominator	:=	1;

							(*Moving X-Axis*)

							AxisCtrl[AxisNo.XAxis].Command.ExternalControl.StartPlus						:=	XMoveManual ;	(*With Side Keys*)

							(* status led touching *)
								MachineCtrl.Peripheral.ExternalControl.StatusLedOnTouch1	:=	TRUE;
								MachineCtrl.Peripheral.ExternalControl.StatusLedOnTouch2	:=	FALSE;

							(* set Event *)
								MachineCtrl.ProcessControl.Event.No		:=	EvNoProcessTouchingNo1;
								MachineCtrl.ProcessControl.Event.En		:=	TRUE;
								MachineCtrl.ProcessControl.Event.SId	:=	EvEventSourceId;
								MachineCtrl.ProcessControl.Event.Class	:=	TcEventClassMessage;
				END_IF;

				AxisCtrl[AxisNo.XAxis].Command.ExternalControl.StartPlus			:=	 MachineCtrl.Peripheral.ExternalControl.Key1Touching ;

			(*Transition*)
				IF	StepAction AND
					( NOT StepActionImPulse ) AND
					(* Confirm Touch Position  *)
					RTrigConfirmTouchposZ.Q
					THEN
						StepNew															:=	136;		(* action: Desable x + Z axis *)
				END_IF;

			(*--------------------------------------------------------------------- Clamping -----------------------------------------------------------------------*)
	136:			(*Action*)
				IF	StepActionImPulse
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdClose	:=	TRUE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdOpen	:=	FALSE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					MachineCtrl.State.ChipBreaker.Auto.Clamping.ClampingIsOn
					THEN
						StepNew			:=	138;
				END_IF;

				(*---------------------------------------Move The  Axis Manually while the SB is clamped-----------------------------------*)
	138:			(*Action*)
				IF	StepActionImPulse
						THEN
							(*----------------------------------------Velocity Calculation------------------------------------------------------*)
						(* calc sawblade circumference *)
							SBCircumference				:=	ActualSawBlade.Diameter*PI;
							(* max feedrate chip breaker  *)
							ChipBreakerAutoXAxisMaxVelo	:=	5.0;
						(* calc velo x-axis degree/s *)
							ChipBreakerAutoVeloTemp		:=	( 360.0 * ChipBreakerAutoXAxisMaxVelo ) / SBCircumference;
							ChipBreakerXAxisVelo			:=	ChipBreakerAutoVeloTemp	;
							(*---------------------------------------------------------------------------------------------------------------------------*)

							(* X-axis *)
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogHandwheel				:=	FALSE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogButtonHandWheel		:=	TRUE;
							AxisCtrl[AxisNo.XAxis].Command.NominalValue.VeloJog						:=	ChipBreakerXAxisVelo;
							(*Z-Axis*)
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJog						:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel				:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloJog						:=	3;			(* 3 mm / second *)
							AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.ExternalEncoderNumber			:=	AxisNo.ZAxisExtENC100.ExtEncNo;
							AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.ExternalEncoderRatioNumerator	:=	36;
							AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.ExternalEncoderRatioDenominator	:=	1;

							(*Moving X-Axis*)

							AxisCtrl[AxisNo.XAxis].Command.ExternalControl.StartPlus						:=	XMoveManual ;	(*With Side Keys*)

				END_IF;

				AxisCtrl[AxisNo.XAxis].Command.ExternalControl.StartPlus			:=	 MachineCtrl.Peripheral.ExternalControl.Key1Touching ;		(*Out Of Impulse so we can Move x Axis As long as not confirmed *)

				(*Transition*)

				IF	StepAction AND
					( NOT StepActionImPulse ) AND
					( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut ) AND
					(NOT AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut) AND
					(* Confirm Touch Position  *)
					RTrigConfirmTouchposZ.Q
					THEN
						StepNew																		:=	140;		(* action: Desable x + Z axis *)
						(*Buuffer Z Position*)
						XPosition																	:=	Axis[AxisNo.XAxis].NcToPlc.ActPos;
						ZPosition																	:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos;
						MachineCtrl.ProcessControl.Event.En												:=	FALSE;
						MachineCtrl.Peripheral.ExternalControl.StatusLedOnTouch1							:=	FALSE;
						MachineCtrl.Peripheral.ExternalControl.StatusLedOnTouch2							:=	FALSE;
						(* default Start X&amp;Z-axis *)
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogHandwheel					:=	FALSE;
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogButtonHandWheel			:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel					:=	FALSE;
				END_IF;

			(*-------------------------------------------------------------------x-z axis Deactivation--------------------------------------------------------------*)

				(*Action*)
	140:			IF	StepActionImPulse
					THEN
					(* set axis state for check *)
						AxisState	:=	STATE_DISABLED;
						(*X-Axis*)
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn						:=	FALSE;
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut					:=	FALSE;
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogButtonHandWheel			:=	FALSE;
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogHandwheel					:=	FALSE;
					(* Reset z-axis *)
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn						:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut					:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJog							:=	FALSE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel					:=	FALSE;
				END_IF;

			(* transition *)

			IF	StepAction AND
				(NOT StepActionImPulse) AND
				(* all axis are disabled *)
					Axis[AxisNo.XAxis].Status.Disabled  AND
					Axis[AxisNo.ZAxis].Status.Disabled
				THEN
					StepNew	:= 150;				(* -&gt; Activate Safety State*)
			END_IF;

		(* ---------------------------------------------------------------- Activate Safety State------------------------------------------------------------*)

			(*Action*)
	150:		IF	StepActionImPulse
				THEN
					MachineCtrl.Peripheral.SafetyState.CmdActivate	:=	TRUE;
			END_IF;

			(*Transition*)

			IF	StepAction AND
				(NOT StepActionImPulse)AND
				MachineCtrl.State.SafetyState.Unit.IsActive
				THEN
					StepNew		:=	160;	(*Event Close Door And Start*)
			END_IF;

			(*------------------------------------------------------Event Close Door And Start---------------------------------------------------------*)
			(*Action*)
	160:		IF	StepActionImPulse
				THEN
						MachineCtrl.ProcessControl.Event.No			:=	EvNoCloseDoorAutoMode;
						MachineCtrl.ProcessControl.Event.En			:=	TRUE;
						MachineCtrl.ProcessControl.Event.SId		:=	EvEventSourceId;
						MachineCtrl.ProcessControl.Event.Class		:=	TcEventClassMessage;
						MachineCtrl.Peripheral.Buzzer.Unit.CmdOn	:=	TRUE;
			END_IF;

			(*Transition*)

			IF	StepAction AND
				(NOT StepActionImPulse) AND
				MachineCtrl.State.Door.Sharpener.IsClosed AND
				MachineCtrl.State.Mode.Automatic.IsActive
				THEN
					StepNew		:=	165;		(*Deactivate safety state*)
					MachineCtrl.ProcessControl.Event.En		:=	FALSE;
			END_IF;
			(*-------------------------------------------Deactivate Safety State And Wait for Start Switch-------------------------------------*)
			(*Action*)
	165:		IF	StepActionImPulse
				THEN
						MachineCtrl.Peripheral.SafetyState.CmdDeactivate	:=	TRUE;
			END_IF;

				(*Wait for while after the Deactivation of  Safety state to avoid the error*)

				TONWaitSafetyStatePause( IN  	:=  	StepAction AND
												( NOT MachineCtrl.Peripheral.SafetyState.CmdDeactivate ) AND
												( NOT MachineCtrl.state.SafetyState.unit.IsActive ),
												 PT 	:= 	TIME#50ms);

				StartButton(CLK:= MachineCtrl.Peripheral.ExternalControl.StartSwitch , Q=&gt; );

				(* transition:  *)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					NOT MachineCtrl.state.SafetyState.unit.IsActive  AND
					(NOT MachineCtrl.Peripheral.SafetyState.CmdDeactivate) AND
					TONWaitSafetyStatePause.Q
					THEN
						StepNew		:=170;
				END_IF;
			(*-----------------------------------------------------------Activation Of Axis X &amp; Z---------------------------------------------------------------*)

				(*Action*)
  	 170:			IF	StepActionImPulse
					THEN
							(* set axis state for check *)
								AxisState	:=	STATE_WAIT_NEWOPERATION;
							(* x-axis - Enable *)
								AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
								AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
								AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdCamming			:=	FALSE;
								AxisCtrl[AxisNo.XAxis].Command.ExternalControl.override				:=	100;
							(* Z-axis - Enable *)
								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
								AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
								AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override				:=	100;
				END_IF;

				(*Transition*)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					AutomaticMode AND
				(* status x-axis *)
					(NOT Axis[AxisNo.XAxis].Status.Disabled) AND
					Axis[AxisNo.XAxis].Status.StandStill AND
					( AxisCtrl[AxisNo.XAxis].feedback.state.ActualFbState = AxisState ) AND
				(* status Z-axis *)
					(NOT Axis[AxisNo.ZAxis].Status.Disabled) AND
					Axis[AxisNo.ZAxis].Status.StandStill AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState ) AND
				(* stop switch not pressed *)
					(PauseSwitchActive)
					THEN
					StepNew	:= 	175;	(* --- move to   x-axis and Z-axis  To definiert positions------- *)
				END_IF;

				(*------------------------------------------------------Needed Calc For The Process--------------------------------------------------------*)
	175:			(*Action*)
				IF	StepActionImPulse
					THEN
							Zx						:=	UI.MachineSpecification.PeripheralOptional.ChipBreaker.ZPosCorrectionResharpRecut*2;
							(*degree per tooth calc*)
							DegPerTeeth			:=	(1/ UINT_TO_LREAL(UI.Order.SawBlade.NumberOfTeeth))  *360;
							(*UpfeedMM calc*)
							ZAxisUpfeedMM		:=
													2*(MachineCtrl.ProcessTemp.ActualJobData.Job.Infeed.TotalInfeed +
													REAL_TO_LREAL (UI.MachineSpecification.PeripheralOptional.ChipBreaker.YOffSet));
							RSS				:=	ActualGrindingWheel.Diameter / 2;
							DSSDiff				:=	200 - ActualGrindingWheel.Diameter;
							WorkingAngle		:=	UI.MachineSpecification.Base.WorkingAngle;
							BSS					:=	ActualGrindingWheel.Layer.Thickness;
							WorkingAngleRAD 	:=	WorkingAngle / 180 * PI;
							YrefPos				:=	YDistanceToTouchPos  -  UI.MachineSpecification.PeripheralBasic.Axis.Y.Position.HomingOffset;
							YendPos			:=	MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.EndPosActOpMode.PosY;	;(* SFC Circular Grinding*)
							DeltaZ				:=	2*(YrefPos-YendPos)*COS(WorkingAngleRAD ) + Zx ;									(*Z-Axis Corrector : Zx*)
							DeltaX				:=	SIN(WorkingAngleRAD )*(YendPos - YrefPos -100+RSS) + 0.5*(BSS-2);
							DeltaX_DEG			:=	( 360.0 / (ActualSawBlade.Diameter * PI) ) * DeltaX;									(*DeltaX MM2DEG*)
							XoffsetInGrad			:=	( 360.0 / (ActualSawBlade.Diameter * PI) ) * UI.MachineSpecification.PeripheralOptional.ChipBreaker.XOffSet;
				END_IF;

				(*Transition*)
				IF	StepAction AND
					(NOT StepActionImPulse)
					THEN
						StepNew		:=	875;
				END_IF;
				(*#######################################END MANUELLE POS#############################################*)

				(*-------------------------------------------------------------Wait For User Interaction---------------------------------------------------*)
	875:			(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	880;
						NextStepPulse	:=	FALSE;
							IF	(   MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.TKCompensationActive)
								THEN
								XPosition		:=	Axis[AxisNo.XAxis].NcToPlc.ActPos;
							END_IF;
				END_IF;

				(* -------------------------------------- move to   x-axis and Z-axis  To defined  positions----------------------------------------- *)
	880	:		(* action  *)
					IF	StepActionImPulse
					THEN
							AxisState	:=	STATE_WAIT_NEWOPERATION;
						(* x-axis - move absolute *)
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogHandwheel	 	:=	FALSE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdCamming			:=	FALSE;
							AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:=	XPosition;
							AxisCtrl[AxisNo.XAxis].Command.NominalValue.VeloMoveAbsolut		:=	3;							(* velocity To Definiert  x-axis Pos *)
							AxisCtrl[AxisNo.XAxis].Command.ExternalControl.override				:=	100;
						(* Z-axis - move absolute *)
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel 		:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut		:=	ZPosition;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut		:=	20;							(* velocity To Definiert  z-axis Pos *)
							AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override				:=	100;

							ActualRevolutions	:=	0;
					END_IF;

					(* transition:  *)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						(* status x-axis *)
							Axis[AxisNo.XAxis].Status.StandStill AND
							Axis[AxisNo.XAxis].Status.InTargetPosition AND
							( NOT AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut ) AND
							( AxisCtrl[AxisNo.XAxis].feedback.state.ActualFbState = AxisState ) AND
						(* status Z-axis *)
							Axis[AxisNo.ZAxis].Status.StandStill AND
							Axis[AxisNo.ZAxis].Status.InTargetPosition AND
							( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut ) AND
							( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
						THEN
							IF 	(NOT ManPosActive)
								THEN
									StepNew	:= 	883;			(* Close Clamping*)
								ELSE
									StepNew	:=	885;
							END_IF;
					END_IF;

			(* -------------------------------------- move to x-axis startpos ----------------------------------------- *)
			(* MachineCtrl.Peripheral.ChipBreaker.Auto.Number_Rev_Chamf.Rev_Chamfering *)
	883	:		(* action  *)
					IF	StepActionImPulse
					THEN
							AxisState	:=	STATE_WAIT_NEWOPERATION;
						(* x-axis - move absolute *)
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogHandwheel	 	:=	FALSE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdCamming			:=	FALSE;

							IF	( NOT  MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.TKCompensationActive)
								THEN
									AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:=		AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut + DegPerTeeth - DeltaX_DEG + XoffsetInGrad;
									ELSE
										IF	(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.Recutting) OR
											(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.ReSharpening)
											THEN
												IF	 (MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.Previous = 'ClockWise')
													THEN
													(*cw previous*)
													AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:=      	Axis[AxisNo.XAxis].NcToPlc.ActPos  -
																															 AxisPhasingCAM.CbaTeethDiff[UI.Order.SawBlade.NumberOfTeeth] +
																															 DegPerTeeth -
																															DeltaX_DEG +
																															 XoffsetInGrad ;
													ELSE	(*ccw*)
													AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:=      	Axis[AxisNo.XAxis].NcToPlc.ActPos  -
																															 AxisPhasingCAM.CbaTeethDiff[UI.Order.SawBlade.NumberOfTeeth - 2] +
																															 DegPerTeeth -
																															DeltaX_DEG +
																															 XoffsetInGrad ;
												END_IF;
											ELSE
													;	 (* Hier Chamfering*)
												IF	(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= 'ChamferingAlternate') OR
													(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= 'ChamferingDual')
													THEN
														IF	 (MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.PreviousPrevious = 'ClockWise')
															THEN
																IF	 (MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.Previous  = 'ClockWise')
																	 THEN ;(*CW*)
																		AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:=      	MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.EndPosActOpMode.PosX_CBA  -
																																				 AxisPhasingCAM.CbaTeethDiff[UI.Order.SawBlade.NumberOfTeeth] +
																																				 DegPerTeeth -
																																				DeltaX_DEG +
																																				 XoffsetInGrad -
																																				(360*2*MachineCtrl.Peripheral.ChipBreaker.Auto.Number_Rev_Chamf.Rev_Chamfering) ;
																		TestArray[0]	:= TRUE;
																	ELSE (*CCW*)
																		AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:=      	MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.EndPosActOpMode.PosX_CBA  -
																																				 AxisPhasingCAM.CbaTeethDiff[UI.Order.SawBlade.NumberOfTeeth] +
																																				 DegPerTeeth -
																																				DeltaX_DEG +
																																				 XoffsetInGrad +
																																				(360*2*MachineCtrl.Peripheral.ChipBreaker.Auto.Number_Rev_Chamf.Rev_Chamfering) ;
																		TestArray[1]	:= TRUE;
																END_IF
															ELSE
																IF	 (MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.Previous  = 'ClockWise')
																	 THEN ;(*CW*)
																		AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:=      	MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.EndPosActOpMode.PosX_CBA  -
																																				 AxisPhasingCAM.CbaTeethDiff[UI.Order.SawBlade.NumberOfTeeth - 2] +
																																				 DegPerTeeth -
																																				DeltaX_DEG +
																																				 XoffsetInGrad  -
																																				(360*2*MachineCtrl.Peripheral.ChipBreaker.Auto.Number_Rev_Chamf.Rev_Chamfering) ; ;
																		TestArray[2]	:= TRUE;
																	ELSE
																		AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:=      	MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.EndPosActOpMode.PosX_CBA  -
																																				 AxisPhasingCAM.CbaTeethDiff[UI.Order.SawBlade.NumberOfTeeth - 2] +
																																				 DegPerTeeth -
																																				DeltaX_DEG +
																																				 XoffsetInGrad  +
																																				(360*2*MachineCtrl.Peripheral.ChipBreaker.Auto.Number_Rev_Chamf.Rev_Chamfering) ; ;
																		TestArray[3]	:= TRUE;
																END_IF;
														END_IF
												END_IF;
														(* Hier Chamfering*)
										END_IF;
	
								END_IF;

							AxisCtrl[AxisNo.XAxis].Command.NominalValue.VeloMoveAbsolut		:=	3;							(* velocity To Definiert  x-axis Pos *)
							AxisCtrl[AxisNo.XAxis].Command.ExternalControl.override				:=	100;
					END_IF;

					(* transition:  *)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						(* status x-axis *)
							Axis[AxisNo.XAxis].Status.StandStill AND
							Axis[AxisNo.XAxis].Status.InTargetPosition AND
							( NOT AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut ) AND
							( AxisCtrl[AxisNo.XAxis].feedback.state.ActualFbState = AxisState )
						THEN
							StepNew	:= 	885;			(* Close Clamping*)
					END_IF;

				(*---------------------------------------------------------Wait For User Interaction------------------------------------------------*)
	885:			IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	890;
						NextStepPulse	:=	FALSE;
						LimitZaxis		:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos - 14;
				END_IF;

				(*-------------------------------------------------------Close- Clamping-----------------------------------------------------------------*)
	890:			(*Action*)
					IF	StepActionImPulse
						THEN
							MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdClose	:=	TRUE;
							MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdOpen	:=	FALSE;
					END_IF;

					TonWaitClamping(		IN	 :=	 StepAction AND
											MachineCtrl.State.ChipBreaker.Auto.Clamping.ClampingIsOn	,
											 PT	:= TIME#500ms,	(*2s*)
											Q=&gt; , ET=&gt; );

					(* transition:  *)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						(* clamping is open *)
						MachineCtrl.State.ChipBreaker.Auto.Clamping.ClampingIsOn AND
						TonWaitClamping.Q
						THEN
							StepNew	:= 	895;		(*Activation Of Turbine*)
					END_IF;

				(*--------------------------------------------------------Wait For User Interaction--------------------------------------------------------*)
	895:			IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	900;
						NextStepPulse	:=	FALSE;
				END_IF;

				(*----------------------------------------------------------- Turbine Activation-----------------------------------------------------------*)
	900:			(*Action : Activate Turbine#8*)

					IF	 StepActionImPulse
						THEN
								MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOn	:=	TRUE;
								MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOff	:=	FALSE;
								NumberTouch			:=	0;
								TriesNumber				:=	0;
					END_IF;

					(*Transition: Is the  Turbine On? *)

					IF	 StepAction 	AND
						 (NOT StepActionImPulse) AND
					    	  MachineCtrl.State.ChipBreaker.Auto.Turbine.IsActive AND
						  MachineCtrl.State.ChipBreaker.Auto.GrindingWheelIsReady
						THEN
							IF	Stepper  AND
								(NOT CbaPneumatic)
								THEN
									StepNew			:=	950	;		(*Servo- Motor *)
								ELSIF	CbaPneumatic AND
										(NOT Stepper)
										THEN
											StepNew		:=	990;		(*Pneumatic Cylinder *)
							END_IF;
							(*DemoMode ?*)
							IF  	UI.MachineSpecification.Base.DemoMode
								THEN
									StepNew				:=	1275;
									ZAxisStartPosition		:=	ZPosition - 4;
							END_IF;
					END_IF;


		(*-----------------------------------------Transition Servo Front/Rear Pos  #10 --------------------------------------------------*)
	950:			(*Action*)
					IF 	ChipBreakerFr
							THEN
								StepNew		:=	980;			(*ChipBreakerFront With Servo *)
								ELSIF	ChipBreakerRe
									THEN
										StepNew		:=	970;	(*ChipBreaker Rear  With Servo *)
					END_IF;
					(*Demo Mode No Need To Move The Stepper*)
					IF	UI.MachineSpecification.Base.DemoMode
						THEN
							StepNew		:=	1110;
					END_IF;
		(*#############################Chip Breaker Rear With Servo##############################-*)


  		(*------------------------------------------------------Wait For User Interaction----------------------------------------------------------*)
	970:			IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew				:= 	 975;;
						NextStepPulse		:=	FALSE;
						StartMonitoringAaxis	:=	TRUE;
						StepMotorDestination	:=	ARearPos;
						AaxisActPosition		:=	 MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos;
				END_IF;
		(*---------------------------------------------------Wait For Confirmation-----------------------------------------------------------*)
	9700:

				IF	RTrigNextStep.Q OR
					TRUE
					THEN
						StepNew	:= 9750;
				END_IF;

		(*-----------Move the A-Axis with a high velocity till it reaches the 80% of destination-----------------------*)

	9750:
				(*Action*)
				IF 	StepActionImpulse
					THEN
					AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
					AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
					AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	0.2;
					AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;
					AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	TRUE;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT StepActionImpulse) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  (ARear80 +AaxisTolerenceSlow)) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  (ARear80 -AaxisTolerenceSlow))
					THEN
						StepNew		:=	975;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus	:=	FALSE;
				END_IF;



	(*--------------------------------------------------------------Move X Axis One tooth----------------------------------------------------------*)

	1110:		(*Action*)
				IF	StepActionImpulse
					THEN
						AxisState														:=	STATE_WAIT_NEWOPERATION;
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
						AxisCtrl[AxisNo.XAxis].Command.ExternalControl.override				:=	100;
						AxisCtrl[AxisNo.XAxis].Command.NominalValue.VeloMoveAbsolut		:=	3;
						AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdCamming			:=	FALSE;

						(*New*)
						MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOff				:=	FALSE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOn				:=	TRUE;



						IF	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.IsActive
							THEN																									(* first tooth pitch *)
								AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:=					Axis[AxisNo.XAxis].NcToPlc.ActPos +
																													FC_MM2DEG( 	MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.SawBlade.Diameter,
																													MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.SawBlade.Shape.ToothShape[0].ToothPitch.Absolute ) +
																													MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.Front[VarioCtrEnd];
							ELSE
								(* Compensatoin not Active*)
								IF	(NOT MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.TKCompensationActive)
									THEN
										AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut				:= 	Axis[AxisNo.XAxis].NcToPlc.ActPos +
																													( 1 * DegPerTeeth );
										ELSE
										(*Test*)

										IF	(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.Recutting) OR
											(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.ReSharpening) OR
											(UI.Order.Job[1].OperatingMode =  OperatingMode.ReSharpening ) OR
											(UI.Order.Job[1].OperatingMode =  OperatingMode.Recutting )
											THEN
												IF	 (MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.Previous = 'ClockWise')
												  	  THEN
														   NoOfActTeethCompensation	:=	1 ; (*cw*)
													   ELSE
														   NoOfActTeethCompensation	:=	TO_INT(UI.Order.SawBlade.NumberOfTeeth) - 1;	(*ccw*)
												END_IF;
											ELSE
												(*Hier Chamfering*) ;
										END_IF;

										AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut				:=
																													Axis[AxisNo.XAxis].NcToPlc.ActPos +
																													( 1 * DegPerTeeth ) -
																													 AxisPhasingCAM.CbaTeethDiff[NoOfActTeethCompensation]	;



										XAxisNextPosition															:=	Axis[AxisNo.XAxis].NcToPlc.ActPos +
																													( 1 * DegPerTeeth ) -
																													 AxisPhasingCAM.CbaTeethDiff[NoOfActTeethCompensation]	;


								END_IF;
						END_IF;

				END_IF;
				(*Transition*)
				IF	StepAction AND
					NOT StepActionImPulse  AND
					(* status x-axis *)
					( NOT Axis[AxisNo.XAxis].Status.Disabled ) AND
					Axis[AxisNo.XAxis].Status.InTargetPosition AND
					( NOT AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut ) AND
					( AxisCtrl[AxisNo.XAxis].feedback.state.ActualFbState = AxisState )
					THEN
						StepNew		:=	1115;

						(* zero is the first element *)
						VarioCtr			:=	-1;
				END_IF;

	(*-----------------------------------------------------------------Keep Cooling On -------------------------------------------------------------------*)

	1115:		(*Action*)
				IF	StepActionImPulse
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOff	:=	FALSE;(*TRUE;*)
						MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOn	:=	TRUE;

							IF	(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.Recutting) OR
								(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.ReSharpening) OR
								(UI.Order.Job[1].OperatingMode =  OperatingMode.ReSharpening ) OR
								(UI.Order.Job[1].OperatingMode =  OperatingMode.Recutting )
								THEN
									IF	 (MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.Previous = 'ClockWise')
										THEN
											NoOfActTeethCompensation	:=	TO_INT(UI.Order.SawBlade.NumberOfTeeth) ; (*cw*)
										ELSE
											NoOfActTeethCompensation	:=	TO_INT(UI.Order.SawBlade.NumberOfTeeth) - 2;  (*ccw*)
									END_IF;
							END_IF;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					MachineCtrl.State.ChipBreaker.Auto.Cooling.IsActive
					THEN
						StepNew		:=	1117;
				END_IF;
	(*---------------------------------------------------------------Wait For User Interaction-----------------------------------------------------------*)
	1117:		(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	1120;
						NextStepPulse	:=	FALSE;
				END_IF;
	(*---------------------------------------------------------Transition Move Rear Position--------------------------------------------------------*)

	1120	:
				TON_Rear	(	 IN	:=	(StepNew = 1120) AND
										StepAction AND
										(NOT StepActionImPulse) AND
										ChipBreakerRe AND
										(NOT ChipBreakerFr),
										 PT	:=	T#1s ,
										 Q	=&gt; ,
										 ET	=&gt;						 );		(*---Wait 2 seconds before starting with the Rear Side-- *)

				(*Transition*)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					TON_Rear.Q
					THEN
						IF	Stepper AND
							(NOT CbaPneumatic )
							THEN
								MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdBackward	:=	FALSE;
								StepNew		:=	1290;
							ELSIF	 CbaPneumatic AND
									(NOT Stepper)
							THEN
								IF	NOT UI.MachineSpecification.Base.DemoMode
									THEN
										StepNew		:=	1125;
									ELSE
										StepNew		:=	1290;
								END_IF;
						END_IF;
				END_IF;
	(*---------------------------------------------------------------REAR-CYLINDRE-10--------------------------------------------------------------------*)
	1125	:		(*Action*)
					IF 	StepActionImpulse  AND
						(NOT MachineCtrl.State.ChipBreaker.Auto.TurbinePosition.InRearPosition) AND
						CbaPneumatic
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdBackward	:=	TRUE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdForward	:=	FALSE;
					END_IF;

					(*Transition*)
					IF 	StepAction AND
						(NOT StepActionImpulse) AND
						(NOT MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdBackward) AND
						 MachineCtrl.State.ChipBreaker.Auto.TurbinePosition.InRearPosition
						THEN
							ZAxisStartPosition		:=	ZAxisStartPosition - UI.MachineSpecification.PeripheralOptional.ChipBreaker.ZDeltaFrontRearPos; (*0.05;*)
							XAxisEndPos			:=	Axis[AxisNo.XAxis].NcToPlc.ActPos  + 360;		(*Calc X Axis End Position*)
							StepNew				:=	1290;
					END_IF;

	(*---------------------------------------------------------------Wait For User Interaction-------------------------------------------------------*)
	1150:		(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	1220;
						NextStepPulse	:=	FALSE;
				END_IF;
	(*----------------------------------------------------------Wait For User Interaction-------------------------------------------------------------*)
	1210:
				(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	1215;
						NextStepPulse	:=	FALSE;
				END_IF;

	(*-----------------------If Double Touch Is Active and Number Of Touch &lt;2:Z-Axis Move Down 3 MM-----------------------*)
	1215:
				(*Action*)
				IF 	StepActionImPulse
					THEN
						AxisState																:=	STATE_WAIT_NEWOPERATION;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override						:=	100;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	FALSE;		(*Down without Touch Probe :to not affect the touchnumber  *)
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut				:= 	 Axis[AxisNo.ZAxis].NcToPlc.ActPos +3;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut				:=	1;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					NOT StepActionImPulse  AND
					(* status z-axis *)
					( NOT Axis[AxisNo.ZAxis].Status.Disabled ) AND
					Axis[AxisNo.ZAxis].Status.InTargetPosition AND
					( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut )AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						StepNew		:=	1217;		(*User Interaction*)
				END_IF;
	(*------------------------------------------------------------Wait For User Interaction-------------------------------------------------------------------*)
	1217:		(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	1220;
						NextStepPulse	:=	FALSE;
				END_IF;

	(*-------------------------------------------------------------------#11-- Z-Axis Move Up -----4 mm----------------------------------------------------*)
	1220	:		(*ACTION*)
					IF	StepActionImPulse
						THEN
							DifferenceMaxMinCBAGWDiameter												:=	 0.5 *
																											( UI.MachineSpecification.PeripheralOptional.ChipBreaker.GrindingWheel.Diameter.Maximal   -
																											 UI.MachineSpecification.PeripheralOptional.ChipBreaker.GrindingWheel.Diameter.Nominal );
							IF	(NOT UI.MachineSpecification.Base.DemoMode)
								THEN
									MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn							:=	TRUE;
							END_IF;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe		:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut					:= 	Axis[AxisNo.ZAxis].NcToPlc.ActPos -  14 (*7 is the org value*) - DifferenceMaxMinCBAGWDiameter;
	
							IF	(NumberTouch=0)
								THEN
									AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut			:=	1;											 (*Velocity to Set*)
									ELSIF	(NumberTouch=1)
										THEN
											AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut	:=	2;
							END_IF;
					END_IF;
					(*Transition: Did Z-Axis Reach The Grinding Wheel?*)
					IF 	StepAction AND
						(NOT StepActionImPulse) AND
						(NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe )

								THEN
									IF	( AxisCtrl[AxisNo.ZAxis].Feedback.State.TouchProbe.ActiveAndAxisStopped)
										THEN
												NumberTouch		:=	NumberTouch + 1;
											(*Calculation Of Number Of Touch*)
												IF	SimpleTouch
													THEN
														XAxisStartPosition													:=	Axis[AxisNo.XAxis].NcToPlc.ActPos;
														XAxisEndPos														:=	Axis[AxisNo.XAxis].NcToPlc.ActPos  + 360;		(*Calc X Axis End Position*)
														ZTouchPos														:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos;
														ZAxisStartPosition													:=	ZTouchPos	+	0.7;							(*Move Z-Axis Down 0.7MM*)
														TouchPositionsZPlausi	[NumberTouch]								:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos;				(*Touch Position Numbre*)
														AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;										(*End Moving Up of Z-Axis*)
														StepNew															:=	1245;										(*Z-Axis Down --&gt; Start Pos*)
												END_IF;
												IF	DoubleTouch
												THEN
														IF	(NumberTouch&lt;2)
															THEN
																StepNew		:=	1210;	(*Move Z Axis Down*)
																	ELSE	(*Touch &gt;=2*)
																		ZTouchPos														:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos;
																		ZAxisStartPosition													:=	ZTouchPos	+	0.7;
																		XAxisStartPosition													:=	Axis[AxisNo.XAxis].NcToPlc.ActPos;
																		XAxisEndPos														:=	Axis[AxisNo.XAxis].NcToPlc.ActPos  + 360;
																		AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;										(*End Moving Up of Z-Axis*)
																		StepNew															:=	1245;										(*Z-Axis Down --&gt; Start Pos*)
														END_IF;
												END_IF;

								ELSE
											StepNew		:=	25000;;						(*If There is No Touch --&gt; ERROR*)
											MachineCtrl.ProcessControl.Warning.No		:=	PSM_Fault_ErrorChipBreakerAuto;
											MachineCtrl.ProcessControl.Warning.En		:=	TRUE;
											MachineCtrl.Peripheral.Buzzer.Unit.CmdOn	:=	TRUE;
											MachineCtrl.ProcessControl.Warning.Data		:=	'';
					END_IF;
				END_IF;


	(*------------------------------------------------------------Wait For User Interaction-----------------------------------------------------*)

	1245:		(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
				(*Transiiton*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	1250;
						NextStepPulse	:=	FALSE;
				END_IF;
	(*---------------------------------------------------------------- Z-Axis Move Down---------------------------------------------------------*)

	1250:		(*Action*)
				IF 	StepActionImPulse
					THEN
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	TRUE;;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut				:= 	ZAxisStartPosition  ;		  (*Moving down to start Pos*)
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut				:=	10;
				END_IF;
				(*Transition :Is The Z-Axis in The  Position *)
				IF 	StepAction AND
					(NOT StepActionImPulse) AND
					(NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut)
					THEN
						DoubleTouch	:=	FALSE;
						IF	DoubleTouch
							THEN
								IF	(NumberTouch &lt;2)
									THEN
										StepNew			:=	1255;			(*Move X-Axis 2 Teeth CCW then--&gt; 122 Again:Move-Z UP*)
									ELSE									(*Number Of Touchs &gt;=2*)
										(*Check Plausibility*)
										StepNew			:=	1265;			(*If OK--&gt;Move X- Axis And Z-Axis To Start Position*)
									END_IF;
							ELSE
								StepNew			:=	1275;
						END_IF;
				END_IF;
	(*------------------------------------------------------------Wait For User Interaction-----------------------------------------------------*)
	1255:		(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	1150;
						NextStepPulse	:=	FALSE;
				END_IF;

	(*------------------------------------------------------------Wait For User Interaction------------------------------------------------------*)
	1265:		(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	1270;
						NextStepPulse	:=	FALSE;
				END_IF;

	(*------------------------------------------------------------------Check Plausibility-------------------------------------------------------------*)
	1270:			(*Action*)
					IF	DoubleTouch
						THEN
							Delta 	:=	ABS	 (TouchPositionsZPlausi[2]	-TouchPositionsZPlausi [1]);					(*Check Of Plausibility*)
							IF	(Delta &lt;= DeltaMax)
							THEN
								StepNew						:=	1275;										(*Start POsition X/Z*)
								TouchPositionsPlausibilityOK 	:= 	TRUE;
								TouchPositionsPlausibilityError	:=	FALSE;
							ELSE
								TouchPositionsPlausibilityOK 	:= 	FALSE;
								TouchPositionsPlausibilityError	:=	TRUE;
								StepNew						:=	25000;										(*ERROR OUT*)
							END_IF;
					END_IF;
	(*-------------------------------------------------------------Wait For User Interaction------------------------------------------------------------*)
	1275:
				(*Action*)
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	1280;
						NextStepPulse	:=	FALSE;
				END_IF;
	(*----------------------------------------------X-Axis &amp; Z-Axis Move To Start Position A--#17----------------------------------------------*)
	1280	:		(*Action*)
					IF	StepActionImPulse
						THEN
							AxisState	:=	STATE_WAIT_NEWOPERATION;
							MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.IsDeactivated	:=	TRUE;
						(* x-axis - move absolute *)
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdCamming			:=	FALSE;
							IF	(NOT UI.MachineSpecification.Base.DemoMode)
								THEN
									AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:=	XAxisStartPosition;			(* Startposition x-axis *)
							END_IF;
							AxisCtrl[AxisNo.XAxis].Command.NominalValue.VeloMoveAbsolut		:=	10;								(* velocity Startpos x-axis *)
							AxisCtrl[AxisNo.XAxis].Command.ExternalControl.override				:=	100;
						(* Z-axis - move absolute *)
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel 		:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut		:=	ZAxisStartPosition;			(* Startposition y-axis *)
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut		:=	10;						(* velocity Startpos z-axis *)
							AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override				:=	100;
							XAxisNextPosition													:=	AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut;

							IF	(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.Recutting) OR
								(MachineCtrl.ProcessTemp.ActualJobData.OperatingMode.Previous= OperatingMode.ReSharpening) OR
								(UI.Order.Job[1].OperatingMode =  OperatingMode.ReSharpening ) OR
								(UI.Order.Job[1].OperatingMode =  OperatingMode.Recutting )
								THEN
									IF	 (MachineCtrl.ProcessTemp.ActualJobData.OperatingDirection.Previous = 'ClockWise')
										THEN
											NoOfActTeethCompensation	:=		TO_INT(UI.Order.SawBlade.NumberOfTeeth) -1 ;				(*previous cw*)
										ELSE
											NoOfActTeethCompensation	:=		TO_INT(UI.Order.SawBlade.NumberOfTeeth) - 3;				(* previous ccw	 *)
									END_IF;
								ELSE
									(*Hier Chamfering *) ;
							END_IF;

					END_IF;

					(*Transition : Is X /Z Axis in Start Position*)

					IF 	StepAction AND
						(NOT StepActionImPulse) AND
						(* status x-axis *)
							Axis[AxisNo.XAxis].Status.StandStill AND
							Axis[AxisNo.XAxis].Status.InTargetPosition AND
							( NOT AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut ) AND
							( AxisCtrl[AxisNo.XAxis].feedback.state.ActualFbState = AxisState ) AND
						(* status Z-axis *)
							Axis[AxisNo.ZAxis].Status.StandStill AND
							Axis[AxisNo.ZAxis].Status.InTargetPosition AND
							( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut ) AND
							( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						StepNew			:=	1290;	(*Z-Axis UpFeed*)
						StartWriting		:=	TRUE;
					END_IF;
	(*-------------------------------------------------------------Wait For User Interaction------------------------------------------------------*)
	1290:	(*Action*)
			IF	StepActionImPulse
				THEN
					IF	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.IsActive
						THEN
							FOR	VarioCtr := 0 TO 11
									DO
										VarioToothPitch[VarioCtr]	:=	FC_MM2DEG( 	MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.SawBlade.Diameter,
																					MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.SawBlade.Shape.ToothShape[VarioCtr].ToothPitch.Absolute );

							END_FOR;

							VarioCtrEnd	:=	( ( MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.ToothNo ) / 2 ) - 1;

							(* predefine rear side *)
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[0,0]	:=	1;
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[0,1]	:=	2;
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[1,0]	:=	3;
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[1,1]	:=	4;
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[2,0]	:=	5;
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[2,1]	:=	6;
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[3,0]	:=	7;
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[3,1]	:=	8;
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[4,0]	:=	9;
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[4,1]	:=	10;
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[5,0]	:=	11;
							MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[5,1]	:=	0;

							IF	( VarioCtrEnd &lt; 5 )
								THEN
									MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[VarioCtrEnd,1]	:=	0;
							END_IF;

							FOR 	VarioCtr := 0 TO VarioCtrEnd
									DO
										VarioCtrFront1	:=	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.FrontPos[VarioCtr,0];
										VarioCtrFront2	:=	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.FrontPos[VarioCtr,1];
										VarioCtrRear1	:=	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[VarioCtr,0];
										VarioCtrRear2	:=	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.RearPos[VarioCtr,1];

										MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.Front[VarioCtr]	:=
																															VarioToothPitch[VarioCtrFront1] +
																															VarioToothPitch[VarioCtrFront2];

										MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.Rear[VarioCtr]	:=
																															VarioToothPitch[VarioCtrRear1] +
																															VarioToothPitch[VarioCtrRear2];
							END_FOR;
						END_IF;
				END_IF;

				(*Transition*)
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	1295;
						NextStepPulse	:=	FALSE;

						(* zero is the first element *)
						VarioCtr			:=	-1;
				END_IF;

	(*----------------------------------------------Calc Velocity For Automatic Process--------------------------------------------------*)

	1295:		(* action:   *)
					IF	StepActionImPulse
						THEN
							(* calc sawblade circumference *)
								SBCircumference				:=	ActualSawBlade.Diameter*PI;
								(* max feedrate chip breaker  *)
								ChipBreakerAutoXAxisMaxVelo	:=	45.0;
							(* calc velo x-axis degree/s *)
								ChipBreakerAutoVeloTemp		:=	( 360.0 * ChipBreakerAutoXAxisMaxVelo ) / SBCircumference;
								ChipBreakerXAxisVelo			:=	ChipBreakerAutoVeloTemp	;
					END_IF;

					(*Transition*)
					IF	StepAction  AND
						(NOT StepActionImPulse)
						THEN
							StepNew		:=	1297;	(*Switch On Cooling *)
					END_IF;
	(*--------------------------------------------------------Switch On Cooling ---------------------------------------------------------------*)
	1297:			(*Action*)
					IF	StepActionImPulse
						THEN
							MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOn	:=	TRUE;
							MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOff	:=	FALSE;
					END_IF;
					(*Transition*)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						MachineCtrl.State.ChipBreaker.Auto.Cooling.IsActive AND
						(NOT MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOn )
						THEN
							StepNew		:=	1300;	(*Start Process*)
					END_IF;


	(*--------------------------------------------------------------------Z-Axis Upfeed-------------------------------------------------------------*)
	1300:			(*Action*)
					IF	StepActionImPulse
						THEN
							MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn			:=	TRUE;
							PauseAvailable												:=	TRUE;
							(*Is Demo Mode Active?*)
						(*	IF	UI.MachineSpecification.Base.DemoMode
								THEN
									ZAxisUpfeedMM	:=	-  ZAxisUpfeedMM - 1;
							END_IF;	*)
						(* set axis state for check *)
							AxisState													:=	STATE_WAIT_NEWOPERATION;
						(*	ZAxisUpfeedMM												:=	ActualJob.Infeed.TotalInfeed; *)
							ZAxisUpfeedPosition											:=	ZAxisStartPosition - (2* ZAxisUpfeedMM) ;
							ActualInfeed													:=	ActualRevolutions * MachineCtrl.ProcessTemp.ActualJobData.Job.Infeed.PartialInfeed;

							IF	( ActualJob.FeedRate.Override &lt;= 0 )
								THEN
									ActualJob.FeedRate.Override	:=	1;
							END_IF;

							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut	:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut	:=	ZAxisStartPosition - ZAxisUpfeedMM - 0.7;			(*= ZAxisUpfeedPosition*)
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut	:=	ActualJob.FeedRate.Nominal *
																							ActualJob.FeedRate.Override;					(* velocity downfeed y-axis *)
							AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override			:=	100;
					END_IF;

					(* transition:  *)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						(* status y-axis *)
							Axis[AxisNo.ZAxis].Status.StandStill AND
							Axis[AxisNo.ZAxis].Status.InTargetPosition AND
							( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
						THEN
							 StepNew			:= 	1305; 								(* Z-Axis Moves Down   *)
					END_IF;

	(*---------------------------------------------------------Wait For User Interaction--------------------------------------------------------------*)
		1305:		IF	StepActionImpulse
						THEN
							NextStepPulse	:=	TRUE;
					END_IF;
	
					IF	StepAction AND
						( RTrigNextStep.Q OR
						ContinousMode )
						THEN
							StepNew			:= 	1310;
							NextStepPulse	:=	FALSE;
					END_IF;

	(*--------------------------------------------------------------- Z-Axis Moves Down ---------------------------------------------------------------- *)
	1310:			(*Action*)
					IF	StepActionImPulse
						THEN
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut		:= 	ZAxisStartPosition ;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut		:=	3.5;
					END_IF;

					(* transition:  *)

					IF	StepAction AND
						(NOT StepActionImPulse) AND
						(* Complete movement *)
						(NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut)
						THEN
							IF	ChipBreakerfr				(*ChipBreaekerIsInFrontPosition*)
								THEN
									NominalTeeth	:=	MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.SawBlade.NumberOfTeeth / 2;
									ActualRevolutions	:=	0;

								ELSIF	 ChipBreakerRe	(*ChipBreaekerIsInRearPosition*)
									THEN
											NominalTeeth	:=	MachineCtrl.ProcessTemp.ActualOrderStackBuffer.ActualOrder.SawBlade.NumberOfTeeth;

											ActualRevolutions	:=	1;
								END_IF;

							ActualTeeth		:=	ActualTeeth + 1;

							IF	( ActualTeeth &gt;= NominalTeeth )
								THEN
										StepNew				:= 	10000;			(*Finish The Process*)
									ELSE
										StepNew				:= 	1350;	(*Actual Teeth &lt;&gt; Nominal Teeth*)
							END_IF;
								ActualInfeed			:=	ActualRevolutions * MachineCtrl.ProcessTemp.ActualJobData.Job.Infeed.PartialInfeed;
								PartialInfeed			:=	MachineCtrl.ProcessTemp.ActualJobData.Job.Infeed.PartialInfeed;
					END_IF;

	(* ---------------------------------------------------------- move x-axis ccw 2 teeth --------------------------------------------------------- *)
	1350:			(* action: *)
					IF	StepActionImPulse
						THEN
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;

							IF	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.IsActive
								THEN
									VarioCtr	:=	VarioCtr + 1;

									IF	ChipBreakerRe	(*Input Variable To set The Side *)
										THEN
											AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut			:= 	Axis[AxisNo.XAxis].NcToPlc.ActPos +
																													MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.Rear[VarioCtr];

										ELSIF	ChipBreakerFr
											THEN
												AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:= 	Axis[AxisNo.XAxis].NcToPlc.ActPos +
																													MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.VarioTooth.Distances.Front[VarioCtr];
									END_IF;

									IF	VarioCtr = VarioCtrEnd
										THEN
											VarioCtr	:=	-1;
									END_IF;

								ELSE
								(*Varion Is Inactive*)
								IF	MachineCtrl.ProcessTemp.ActualJobData.SpecialTooth.TKCompensationActive
									THEN
										IF	NoOfActTeethCompensation &lt;&gt; 1
											THEN
											XAxisNextPosition	:=		 Axis[AxisNo.XAxis].NcToPlc.ActPos
															         + ( 2*DegPerTeeth -
																 AxisPhasingCAM.CbaTeethDiff[NoOfActTeethCompensation] -
																 AxisPhasingCAM.CbaTeethDiff[NoOfActTeethCompensation -1] );
											ELSE
											XAxisNextPosition	:=		 Axis[AxisNo.XAxis].NcToPlc.ActPos
															         + ( 2*DegPerTeeth -
																 AxisPhasingCAM.CbaTeethDiff[1] -
																 AxisPhasingCAM.CbaTeethDiff[UI.Order.SawBlade.NumberOfTeeth] );
										END_IF;

										AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:= 	XAxisNextPosition;
									ELSE
										AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut		:= 	Axis[AxisNo.XAxis].NcToPlc.ActPos + ( 2 *	DegPerTeeth );
								END_IF;
							END_IF;

							AxisCtrl[AxisNo.XAxis].Command.NominalValue.VeloMoveAbsolut					:=	ChipBreakerXAxisVelo;
							AxisCtrl[AxisNo.XAxis].Command.ExternalControl.override							:=	100;
					END_IF;

					(* transition:  *)

					IF	StepAction AND
						(NOT StepActionImPulse) AND
						(* Complete movement *)
						NOT AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut
						THEN

						IF	ActualTeeth &lt; NominalTeeth
							THEN
								NoOfActTeethCompensation		:=		NoOfActTeethCompensation   -   2 ;
								ELSIF
									(ActualTeeth = NominalTeeth)
								THEN
								;
						END_IF;

						IF	NoOfActTeethCompensation &lt;0
							THEN
								NoOfActTeethCompensation	:=	TO_INT(UI.Order.SawBlade.NumberOfTeeth) + NoOfActTeethCompensation ;
						END_IF;

						IF	NoOfActTeethCompensation =0
							THEN
								NoOfActTeethCompensation	:=	TO_INT(UI.Order.SawBlade.NumberOfTeeth)  ;
						END_IF;

							IF 	(XAxisEndPos =AxisCtrl[AxisNo.XAxis].Command.NominalValue.PositionMoveAbsolut)		(*Check If X Reached The End Position*)
								THEN
									ContinousMode	:=	FALSE;
									StepNew		:= 	9000;														(*Check  side  finished*)
									ELSE
										IF	PauseRequested
											THEN
												ContinousMode	:=	FALSE;
												PauseAvailable	:=	FALSE;
												StepNew			:= 	30050;										(* -&gt; pause Routine *)
											ELSE
												StepNew			:=	1300;										(*Z-Axis Upfeed*)
										END_IF;
							END_IF;
					END_IF;

	(*---------------------------------------------------------Wait For User Interaction----------------------------------------------------------*)
	9000:		IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	10000;
						NextStepPulse	:=	FALSE;
				END_IF;
	(*---------------------------------------------------------------End Front Side -----------------------------------------------------------------*)
	10000:		(*Transition*)
				IF	ChipBreakerFr AND
					(NOT ChipBreakerRe)
					THEN
					StepNew		:=	15000;				(*END_Front Side  *)
					XaxisEndPOsFront	:=	Axis[AxisNo.XAxis].NcToPlc.ActPos;
						ELSIF	ChipBreakerRe
					THEN
						StepNew		:=	10050;	(*Proceed to the End of Process*)
						MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn	:=	FALSE;
				END_IF;
	(*-------------------------------------------------------Wait For User Interaction----------------------------------------------------------*)
	10050:
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	10100;
						NextStepPulse	:=	FALSE;
				END_IF;

	(* ----------------------------------------------------------- disable  Turbine  -------------------------------------------------------------- *)
	10100:		(* action *)
					IF	StepActionImPulse
						THEN
							MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOn	:=	FALSE;
							MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOff	:=	TRUE;
					END_IF;

					(* transition *)
					IF	StepAction AND
						( NOT StepActionImPulse ) AND
						( NOT MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOn )
						THEN
							StepNew		:=	10120;		(*Switch Off Fan*)
					END_IF;
	(*----------------------------------------------------------Switch Off Cooling -------------------------------------------------------*)
	10120:
					(*Action*)
					IF	StepActionImPulse
						THEN
							MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOn	:=	FALSE;
							MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOff	:=	TRUE;
					END_IF;
					(*Transition*)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						MachineCtrl.State.ChipBreaker.Auto.Cooling.IsInactive  AND
						(NOT MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOff )
						THEN
							StepNew		:=	10150;	(* -&gt;Release Clamping *)
					END_IF;
	(*--------------------------------------------------Wait For User Interaction------------------------------------------------------------*)
	10150:		IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	10200;			(*Release Clamping*)
						NextStepPulse	:=	FALSE;
				END_IF;

	(*--------------------------------------------------------- Release clamping ------------------------------------------------------------- *)
	10200:		(* action *)
					IF	StepActionImPulse
						THEN
							MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdClose	:=	FALSE;
							MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdOpen	:=	TRUE;
					END_IF;

					(* transition:  *)
					IF	StepAction AND
						(NOT StepActionImPulse) AND
						(* clamping is opene *)
						MachineCtrl.State.ChipBreaker.Auto.Clamping.IsReleased
						THEN
							StepNew	:= 	10450;										(*Z-Axis--&gt;Ref Pos &amp; Saw Blade Bracket To Home Pos*)
					END_IF;
	(*--------------------------------------------Wait For User Interaction-------------------------------------------------------*)
	10450:		IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	10500;
						NextStepPulse	:=	FALSE;
				END_IF;
	(* ------------------------------------------------------------ sfc finished ---------------------------------------------------------- *)
	10500:		(*Action*)
					IF	 StepActionImPulse AND
						(NOT  AxisCtrl[AxisNo.ZAxis].feedback.state.DriveManagment.InHandoverPositionWindow)
						THEN
							(* Z-axis - move absolute *)
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel 		:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut		:=	100;
							AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut		:=	UI.MachineSpecification.PeripheralBasic.Axis.Positions.HandOver;
							MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn				:=	FALSE;
					END_IF;

					(*Transition : Is Z- Axis In Handover Pos?*)

					IF     	StepAction AND
					   	 (NOT StepActionImPulse) AND
						 AxisCtrl[AxisNo.ZAxis].feedback.state.DriveManagment.InHandoverPositionWindow
						THEN
							StepNew			:=	10700;							(*SB Support Bracket To Home Pos*)
							ContinousMode	:=	FALSE;
					END_IF;
	(*----------------------------------------------Wait For User Interaction------------------------------------------------*)
	10700:
					IF	StepAction AND
						NOT StepActionImPulse
						THEN
							IF	Stepper  AND
								(NOT CbaPneumatic)
								THEN
									IF	(NOT UI.MachineSpecification.Base.DemoMode)
										THEN
											StepNew		:=	10750;
										ELSE
											StepNew		:=	11000;
									END_IF;

								ELSIF	(NOT Stepper)  AND
										 CbaPneumatic
								THEN
									IF	(NOT UI.MachineSpecification.Base.DemoMode)
										THEN
											StepNew		:=	10800;
										ELSE
											StepNew		:=	11000;
									END_IF;
							END_IF;
					END_IF;

	(*----------------------------------------------------Move A-Stepper To Ref position------------------------------- *)
	10750:
				IF 	StepActionImpulse
					THEN
						AxisCtrl[AxisNo.AAxis].Command.OperationMode.CmdJog				:=	TRUE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.Override				:=	100;
						AxisCtrl[AxisNo.AAxis].Command.NominalValue.VeloJog				:=	0.5;
						IF	(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=   UI.MachineSpecification.PeripheralOptional.ChipBreaker.Notch.SBEdgeOffset)
							THEN
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	TRUE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;;
							ELSE
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;
								AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	TRUE;;
						END_IF;
						StartMonitoringAaxis												:=	TRUE;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT  StepActionImpulse) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &gt;=  ( UI.MachineSpecification.PeripheralOptional.ChipBreaker.Notch.SBEdgeOffset  - AaxisTolerenceSlow)) AND
					(MachineCtrl.State.ChipBreaker.Auto.AaxisActualPos &lt;=  (  UI.MachineSpecification.PeripheralOptional.ChipBreaker.Notch.SBEdgeOffset + AaxisTolerenceSlow))
					THEN
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;;
						StepNew			:=	11000;
				END_IF;

	(*----------------------------------------------------Move  Cylindre To Front Position------------------------------- *)

	10800:		(*Action*)
				IF 	StepActionImpulse AND
					(NOT MachineCtrl.State.ChipBreaker.Auto.TurbinePosition.InFrontPosition)
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdBackward	:=	FALSE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdForward	:=	TRUE;
				END_IF;
				(*Transition*)
				IF 	StepAction AND
					(NOT StepActionImpulse) AND
					(NOT MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdForward) AND
					 MachineCtrl.State.ChipBreaker.Auto.TurbinePosition.InFrontPosition
					THEN
							StepNew		:=	11000;
				END_IF;
	(*--------------------------------------CBA Swivel UnitTo Home Position----------------------------------------*)
	11000:		(*Action*)
					IF	StepActionImPulse
						THEN
							MachineCtrl.Peripheral.ChipBreaker.Auto.SwivelUnit.CmdHomePos	:=	TRUE;
							MachineCtrl.Peripheral.ChipBreaker.Auto.SwivelUnit.CmdWorkPos	:=	FALSE;
							StartMonitoringAaxis											:=	FALSE;
					END_IF;
					(*Transition*)
					IF 	StepAction AND
						(NOT StepActionImPulse) AND
						MachineCtrl.State.ChipBreaker.Auto.SwivelUnit.InHomePosition
						THEN
							StepNew		:=	11010;	(*Wait for New Operation*)
					END_IF;

	(*----------------------------------------------------Wait For User Interaction-----------------------------------------------*)
	11010:
					IF	StepActionImpulse
						THEN
							NextStepPulse	:=	TRUE;
					END_IF;
	
					IF	StepAction AND
						( RTrigNextStep.Q OR
						ContinousMode )
						THEN
							StepNew			:= 	15000;
							NextStepPulse	:=	FALSE;
					END_IF;
	(*---------------------------------------Step 10 : Wait for New Operation-------------------------------------------*)

	15000:		(* transition *)
					IF	StepAction AND
						(NOT StepActionImPulse)
							THEN
								IF 	ChipBreakerRe
									THEN
										StepNew				:= 	16000;			(*Wait For New Operation*)
										MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.IsDeactivated	:=	FALSE;
										Done				:=	TRUE;
										Start					:=	FALSE;
										ChipBreakerFr		:=	TRUE;
										ChipBreakerRe		:=	FALSE;
									ELSIF 	ChipBreakerFr
										THEN
										ChipBreakerFr	:=	FALSE;
										ChipBreakerRe	:=	TRUE;
										IF	Stepper AND
											(NOT CbaPneumatic)
											THEN
												StepNew			:= 	950;		(*Start With The Rear Side*)
											ELSIF	CbaPneumatic AND
													(NOT Stepper)
											THEN
												StepNew			:= 	990;
										END_IF;
										Done	:=	FALSE;
								END_IF;
					END_IF;

	(*---------------------------------------Wait For User Interaction---------------------------------------------------------*)
	16000:		IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	10;
						NextStepPulse	:=	FALSE;
				END_IF;

	(*--##################################---ERROR-###################################- *)

	25000:		(*Action*)
				IF	 StepActionImPulse
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn			:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus			:=	FALSE;
						AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus			:=	FALSE;		(*Stop Moving   A-Axis*)
						ErrorOut			:=	TRUE;
				END_IF;
				(*Transition*)

				IF 	StepAction AND
					(NOT StepActionImPulse)
					THEN
						StepNew		:=	0;
						ErrorOut		:=	FALSE;
				END_IF;
	(* ####################################### pause sfc ################################ *)

	(*-----------------------------------------------------------Wait For User Interaction------------------------------------------------*)
	30050:
				 IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	30100;		(*Release Clamping*)
						NextStepPulse	:=	FALSE;
				END_IF;

	(*--------------------------------------------------------------Release Clamping-----------------------------------------------------*)
	30100:
					(*Action*)
				IF	StepActionImPulse
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdClose	:=	FALSE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdOpen	:=	TRUE;
				END_IF;

				(* transition:  *)

				IF	StepAction AND
					(NOT StepActionImPulse) AND
					MachineCtrl.State.ChipBreaker.Auto.Clamping.IsReleased
					THEN
						StepNew	:= 	30200;					(*Z Axis Move   down 100 MM*)
				END_IF;
	(* ----------------------------------------------------- wait for user interaction  ---------------------------------------------------- *)
	30200:
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	30250;
						NextStepPulse	:=	FALSE;
				END_IF;
	(* ------------------------------------------------- sfc Paused: move Z-axisDown ------------------------------------------------- *)

	30250	:	(* action: move z-axis down  *)
				IF	StepActionImPulse
					THEN
					(* set axis state for check *)
						AxisState	:=	STATE_WAIT_NEWOPERATION;
					(* move y-axis to reference point *)
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn					:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	TRUE;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut				:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos	+100;
						AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut				:=	30;
						MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn						:=	FALSE;
				END_IF;

				(* transition *)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					(* status Z-axis *)
					Axis[AxisNo.ZAxis].Status.StandStill AND
					Axis[AxisNo.ZAxis].Status.InTargetPosition AND
					( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut ) AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						StepNew		:= 30300;															(*Turbine Off*)
				END_IF;

	(* ---------------------------------------------------- wait for user interaction  ------------------------------------------------------------ *)
	30300:		IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	30350;	(*Turbine Off*)
						NextStepPulse	:=	FALSE;
				END_IF;

	(* --------------------------------------------------------------- Turbine Off --------------------------------------------------------------------- *)
	30350	:	(* action:   *)
				IF	StepActionImPulse
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOn	:=	FALSE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOff	:=	TRUE;
				END_IF;
				(* transition: *)
				IF	StepAction AND
					( NOT StepActionImPulse ) AND
					( NOT MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOn )AND
					(NOT MachineCtrl.State.ChipBreaker.Auto.Turbine.IsActive)			(*Turbine Is Inactive*)
					THEN
							StepNew		:=	30370	;
				END_IF;

	(*-------------------------------------------------------Switch Off Cooling --------------------------------------------------------------------*)
	30370:
				(*Action*)
				IF	StepActionImPulse
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOn	:=	FALSE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOff	:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					MachineCtrl.State.ChipBreaker.Auto.Cooling.IsInactive  AND
					(NOT MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOff )
					THEN
						StepNew		:=	30400;	(* -&gt;deactivate axis x/z *)
				END_IF;
	(* ------------------------------------------------------ wait for user interaction  -------------------------------------------------------------- *)
	30400:
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	30450;
						NextStepPulse	:=	FALSE;
				END_IF;
	(*---------------------------------------------------------------Desable X/Z Axis-----------------------------------------------------------------*)
	30450:
				(* action:   *)
				IF	StepActionImPulse
					THEN
						(* set axis state for check *)
							AxisState	:=	STATE_INIT;
						(* x-axis - disable *)
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn			:=	FALSE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
							AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdCamming			:=	FALSE;
						(* z-axis - disable *)
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
							AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
				END_IF;
				(* transition:  *)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					(* status x-axis *)
						Axis[AxisNo.XAxis].Status.Disabled AND
						( AxisCtrl[AxisNo.XAxis].feedback.state.ActualFbState = AxisState ) AND
					(* status z-axis *)
						Axis[AxisNo.ZAxis].Status.Disabled AND
						( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
						THEN
							StepNew		:= 	30460;			(*User Interaction*)
				END_IF;
	(* ------------------------------------------------------------- wait for user interaction  -------------------------------------------------------- *)
	30460:
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	30470;		(* -&gt; Activate Safety State*)
						NextStepPulse	:=	FALSE;
				END_IF;
	(* -------------------------------------------------------- Activate Safety State -------------------------------------------------------------- *)
	30470:				(*Action*)
				IF	StepActionImPulse
					THEN
					(* Enable safe state  *)
						MachineCtrl.Peripheral.SafetyState.CmdActivate	:=	TRUE;
						MachineCtrl.State.GrindingWheel.PauseIsActive	:=	TRUE;
				END_IF;
				(* transition:  *)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					(* state safety state *)
					( NOT MachineCtrl.Peripheral.SafetyState.CmdActivate ) AND
					MachineCtrl.state.SafetyState.unit.IsActive
					THEN
						StepNew		:=	30500;
				END_IF;

	(*--------------------------------------------------------------------Set Event----------------------------------------------------------------------*)
				(*Action*)
	30500:
				IF	StepActionImPulse
					THEN
				(* set Event *)
						MachineCtrl.ProcessControl.Event.No		:=	EvNoStartStop;
						MachineCtrl.ProcessControl.Event.En		:=	TRUE;
						MachineCtrl.ProcessControl.Event.SId	:=	EvEventSourceId;
						MachineCtrl.ProcessControl.Event.Class	:=	TcEventClassMessage;
						MachineCtrl.Peripheral.Buzzer.Unit.CmdOn:=	TRUE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					(NOT StepActionImPulse)
					THEN
						StepNew		:=	30520;
				END_IF;

	(* --------------------------------------------------------- wait for user interaction  ---------------------------------------------------------- *)
	30520:		IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn					:=	FALSE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.IsDeactivated	:=	FALSE;
						StepNew			:= 	30550;	(*Deactivate Safety  State *)
						NextStepPulse	:=	FALSE;
						Paused			:=	TRUE;
				END_IF;
	(* -----------------------------------------------------Deactivate Safety State---------------------------------------------------------- *)
	30550:			(* action:   *)
				IF	MachineCtrl.state.SafetyState.unit.IsActive
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.IsDeactivated	:=	FALSE;
						IF	MachineStateSharpenerDoorIsClosed AND
							AutomaticMode
							THEN
								(* Disable safe state  *)
								MachineCtrl.Peripheral.SafetyState.CmdDeactivate	:=	TRUE;
								MachineCtrl.State.GrindingWheel.PauseIsActive	:=	FALSE;
							ELSE
								(* Disable safe state  *)
								MachineCtrl.Peripheral.SafetyState.CmdDeactivate	:=	FALSE;
								MachineCtrl.Peripheral.SafetyState.CmdActivate	:=	TRUE;
								MachineCtrl.State.GrindingWheel.PauseIsActive	:=	TRUE;
						END_IF;
				END_IF;

				TONWaitSafetyStatePause( IN  	:=  	StepAction AND
												( NOT MachineCtrl.Peripheral.SafetyState.CmdDeactivate ) AND
												( NOT MachineCtrl.state.SafetyState.unit.IsActive ),
										 PT 	:= 	TIME#50ms);

				(* transition:  *)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					(* state safety state *)
						( NOT MachineCtrl.Peripheral.SafetyState.CmdDeactivate ) AND
						( NOT MachineCtrl.state.SafetyState.unit.IsActive ) AND
						TONWaitSafetyStatePause.Q (* AND
					StartSwitch *)
					THEN
						MachineCtrl.ProcessControl.Event.No		:=	0;
						MachineCtrl.ProcessControl.Event.En		:=	FALSE;
						StepNew								:= 	30600;	(*Turbine On*)
				END_IF;

	(* ----------------------------------------------------------- wait for user interaction  ------------------------------------------------ *)
	30600:		IF	StepActionImpulse
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.IsDeactivated	:=		TRUE;
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	30650;			(*Activate Turbine *)
						NextStepPulse	:=	FALSE;
				END_IF;

	(*------------------------------------------------------------------Turbine On--------------------------------------------------------------------*)
	30650:			(*Action*)
				IF	 StepActionImPulse
						THEN
							MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOn	:=	TRUE;
							MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOff	:=	FALSE;
				END_IF;
				(*Transition: Is the  Turbine On? *)
				IF	 StepAction 	AND
					 (NOT StepActionImPulse) AND
				    	  MachineCtrl.State.ChipBreaker.Auto.Turbine.IsActive
					THEN
						StepNew		:=	30660;		(*Switch On Cooling Fan*)
				END_IF;

	(*---------------------------------------------------- Switch On Cooling -------- --------------------------------------------------------------*)

	30660:
			(*Action*)
				IF	StepActionImPulse
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOn	:=	TRUE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOff	:=	FALSE;
				END_IF;
				(*Transition*)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					MachineCtrl.State.ChipBreaker.Auto.Cooling.IsActive AND
					(NOT MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOn )
					THEN
						StepNew		:=	30670;	(*Start Process*)
				END_IF;

	(* ---------------------------------------------------- wait for user interaction  ------------------------------------------------------------ *)
	30670:
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	30680;			(*Open Clamping*)
						NextStepPulse	:=	FALSE;
				END_IF;
	(* ------------------------------------------------------- sfc Paused: Open Clamping ---------------------------------------------------- *)
	30680	:		(*Action*)
				IF	StepActionImPulse
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdClose	:=	FALSE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdOpen	:=	TRUE;
				END_IF;
				(* transition:  *)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					MachineCtrl.State.ChipBreaker.Auto.Clamping.IsReleased
				THEN
						StepNew	:= 	30700;			(*Move Z To Start Pos*)
				END_IF;

	(* ----------------------------------------------------------- wait for user interaction  --------------------------------------------------------- *)
	30700:		IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	30710;
						NextStepPulse	:=	FALSE;
				END_IF;

	(*----------------------------------------------------------Move Z Axis To Start Pos-----------------------------------------------------------*)
	30710:
					(*Action*)
				IF	StepActionImPulse
				THEN
					AxisState	:=	STATE_WAIT_NEWOPERATION;
				(* Z-axis - move absolute *)
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel 		:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut		:=	ZAxisStartPosition;			(* Startposition y-axis *)
					AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut		:=	15;						(* velocity Startpos z-axis *)
					AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override				:=	100;
				END_IF;

				(*Transition : Is /Z Axis in Start Position*)
				IF 	StepAction AND
					(NOT StepActionImPulse) AND
					(* status Z-axis *)
						Axis[AxisNo.ZAxis].Status.StandStill AND
						Axis[AxisNo.ZAxis].Status.InTargetPosition AND
						( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut ) AND
						( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
				THEN
					StepNew		:=	30800;		(*Clamping*)
				END_IF;

	(* ---------------------------------------------------- wait for user interaction  ------------------------------------------------------------- *)
	30800:
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;

				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	30860; (*Close Clamping*)
						NextStepPulse	:=	FALSE;
				END_IF;
	(*-----------------------------------------------------------------Close Klamping------------------------------------------------------------*)
	30860:
				(*Action*)
				IF	StepActionImPulse
					THEN
						MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdClose	:=	TRUE;
						MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdOpen	:=	FALSE;
				END_IF;

				WaitAfterPause(IN:=	StepAction AND
									(NOT StepActionImPulse) AND
									(* clamping is open *)
									MachineCtrl.State.ChipBreaker.Auto.Clamping.ClampingIsOn ,
									PT:=TIME#2s , Q=&gt; , ET=&gt; );

				(* transition:  *)
				IF	StepAction AND
					(NOT StepActionImPulse) AND
					(* clamping is open *)
					MachineCtrl.State.ChipBreaker.Auto.Clamping.ClampingIsOn AND
					WaitAfterPause.Q
					THEN
						StepNew				:=	30910 	;	(*30910/Pause Step*)
						Paused				:=	FALSE;
						PauseRequested		:=	FALSE;
				END_IF;
	(* --------------------------------------------------------- wait for user interaction  ------------------------------------------------------------ *)
	30910:
				IF	StepActionImpulse
					THEN
						NextStepPulse	:=	TRUE;
				END_IF;
	
				IF	StepAction AND
					( RTrigNextStep.Q OR
					ContinousMode )
					THEN
						StepNew			:= 	30915; 					(*Enable X/Z Axis*)
						NextStepPulse	:=	FALSE;
				END_IF;

	(*-------------------------------------------------------------------Enable Axis---------------------------------------------------------------------*)
	30915:	(*Action*)
			IF	StepActionImPulse
				THEN
				(* set axis state for check *)
					AxisState	:=	STATE_WAIT_NEWOPERATION;
				(* x-axis - Enable *)
					AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
					AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
					AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdCamming			:=	FALSE;
					AxisCtrl[AxisNo.XAxis].Command.ExternalControl.override				:=	100;
				(* z-axis - Enable *)
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override				:=	100;
			END_IF;

			(* transition: axis are Enabled? *)
			IF	StepAction AND
				(NOT StepActionImPulse) AND
				(* status x-axis *)
					(NOT Axis[AxisNo.XAxis].Status.Disabled) AND
					Axis[AxisNo.XAxis].Status.StandStill AND
					( AxisCtrl[AxisNo.XAxis].feedback.state.ActualFbState = AxisState ) AND
				(* status Z-axis *)
					(NOT Axis[AxisNo.ZAxis].Status.Disabled) AND
					Axis[AxisNo.ZAxis].Status.StandStill AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState ) AND
				(* stop switch not pressed *)
					(PauseSwitchActive)
				THEN
					StepNew	:= 	30920;								(* -&gt; User Interaction *)
			END_IF;

	(* -------------------------------------------------------------- wait for user interaction  ----------------------------------------------------- *)
	30920:
			IF	StepActionImpulse
				THEN
					NextStepPulse	:=	TRUE;
			END_IF;

			IF	StepAction AND
				( RTrigNextStep.Q OR
				ContinousMode )
				THEN
					MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn	:=	TRUE;
					StepNew			:= 	1300; 			(*Pause-Step : X/Z Start Pos , Or 1300 : Z-Axis Upfeed*)
					NextStepPulse	:=	FALSE;
			END_IF;
	(*##########################################STOP#########################################*)

	(*-------------------------------------------------------------------Stop Z-Axis--------------------------------------------------------------------*)

	31000:	(*Action*)
			IF	 StepActionImPulse
				THEN
					(* set axis state for check *)
					AxisState	:=	STATE_WAIT_NEWOPERATION;
					(* Z-axis - move absolute Stopped *)
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel 		:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut		:=	(*50;*)0;
					AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut		:=	UI.MachineSpecification.PeripheralBasic.Axis.Positions.HandOver;
					MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn				:=	FALSE;
					StartMonitoringAaxis												:=	FALSE;
			END_IF;
				(*Transition Z-Axis *)
				IF     	StepAction AND
				   	 (NOT StepActionImPulse) AND
					(AutomaticMode OR MachineCtrl.State.Mode.InitSetUp.IsActive  ) AND
					(* status Z-axis *)
					(NOT Axis[AxisNo.ZAxis].Status.Disabled) AND
					Axis[AxisNo.ZAxis].Status.StandStill AND
					( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
					THEN
						StepNew		:= 31020	;		(*Stop Turbine*)
				END_IF;
	(*-------------------------------------------------------------Wait For User Interaction-----------------------------------------------------------*)
	31020:
			IF	StepActionImpulse
				THEN
					NextStepPulse	:=	TRUE;
			END_IF;

			IF	StepAction AND
				( RTrigNextStep.Q OR
				ContinousMode )
				THEN
					StepNew			:= 	31030; 				(*Stop Z-Axis*)
					NextStepPulse	:=	FALSE;
					StartWaitAaxis	:=	TRUE;
			END_IF;

	(*-----------------------------------------------------------------Turbine Off----------------------------------------------------------------------------*)
	31030:
			(* action:   *)
			IF	StepActionImPulse
				THEN
					MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOn	:=	FALSE;
					MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOff	:=	TRUE;
			END_IF;

			IF	StepAction AND
				( NOT StepActionImPulse ) AND
				( NOT MachineCtrl.Peripheral.ChipBreaker.Auto.Turbine.CmdOn )AND
				(NOT MachineCtrl.State.ChipBreaker.Auto.Turbine.IsActive)
				THEN
					StepNew		:=	31100;									(* Switch Off Cooling Fan *)
			END_IF;
	(*-----------------------------------------------------------Switch Off Cooling ----------------------------------------------------------------------*)
	31100:
			(*Action*)
			IF	StepActionImPulse
				THEN
					MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOn	:=	FALSE;
					MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOff	:=	TRUE;
					StartWaitAaxis										:=	FALSE;
			END_IF;
			(*Transition*)
			IF	StepAction AND
				(NOT StepActionImPulse) AND
				MachineCtrl.State.ChipBreaker.Auto.Cooling.IsInactive  AND
				(NOT MachineCtrl.Peripheral.ChipBreaker.Auto.Cooling.CmdOff )
				THEN
					StepNew		:=	31300;			(*Release Clamping*)
			END_IF;
	(*------------------------------------------------------------Wait For User Interaction-------------------------------------------------------------*)
	31300:
			IF	StepActionImpulse
				THEN
					NextStepPulse	:=	TRUE;
			END_IF;

			IF	StepAction AND
				( RTrigNextStep.Q OR
				ContinousMode )
				THEN
					StepNew			:= 	31320; 				(*Release Clamping*)
					NextStepPulse	:=	FALSE;
			END_IF;
	(*---------------------------------------------------------------------Move Z-Axis Dwn 5 MM-----------------------------------------------------------      *)
	31320:
			IF 	StepActionImPulse
				THEN
					AxisState																:=	STATE_WAIT_NEWOPERATION;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn					:=	TRUE;;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut				:=	TRUE;
					AxisCtrl[AxisNo.ZAxis].Command.ExternalControl.override						:=	100;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolutTouchProbe	:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut				:=	Axis[AxisNo.ZAxis].NcToPlc.ActPos + 5;
					AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut				:=	2;
			END_IF;
			(*Transition*)
			IF	StepAction AND
				NOT StepActionImPulse  AND
				(* status z-axis *)
				( NOT Axis[AxisNo.ZAxis].Status.Disabled ) AND
				Axis[AxisNo.ZAxis].Status.InTargetPosition AND
				Axis[AxisNo.ZAxis].Status.StandStill	AND
				( NOT AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut )AND
				( AxisCtrl[AxisNo.ZAxis].feedback.state.ActualFbState = AxisState )
				THEN
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut	:=	FALSE;
					StepNew		:=	31350;
			END_IF
	(*-------------------------------------------------------------------Release clamping----------------------------------------------------------------*)
	31350:
			(*Action*)
			IF	StepActionImPulse AND
				(NOT MachineCtrl.State.ChipBreaker.Auto.Clamping.IsReleased)
				THEN
					MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdClose	:=	FALSE;
					MachineCtrl.Peripheral.ChipBreaker.Auto.Clamping.CmdOpen	:=	TRUE;
			END_IF;

			(* transition:  *)
			IF	StepAction AND
				(NOT StepActionImPulse) AND
				MachineCtrl.State.ChipBreaker.Auto.Clamping.IsReleased
			THEN
					StepNew	:= 	31360;					(*Z Axis  down*)
			END_IF;

	(*---------------------------------------------------------------Wait For User Interaction--------------------------------------------------------------*)
	31360:
			IF	StepActionImpulse
				THEN
					NextStepPulse	:=	TRUE;
			END_IF;

			IF	StepAction AND
				( RTrigNextStep.Q OR
				ContinousMode )
				THEN
					StepNew			:= 	31370; 				(*Move Z -axis To Handover Position*)
					NextStepPulse	:=	FALSE;
			END_IF;
	(*-----------------------------------------------------------Move Z-Axis To handover Position-----------------------------------------------------*)
	31370:
			(*Action*)
			IF	 StepActionImPulse AND
				(NOT  AxisCtrl[AxisNo.ZAxis].feedback.state.DriveManagment.InHandoverPositionWindow)
				THEN
					(* Z-axis - move absolute *)
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn			:=	TRUE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel 		:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut		:=	TRUE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdCamming			:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.NominalValue.VeloMoveAbsolut		:=	100;
					AxisCtrl[AxisNo.ZAxis].Command.NominalValue.PositionMoveAbsolut		:=	UI.MachineSpecification.PeripheralBasic.Axis.Positions.HandOver;
			END_IF;
				(*Transition : Is Z- Axis In Handover Pos?*)
				IF     	StepAction AND
				   	 (NOT StepActionImPulse) AND
					 AxisCtrl[AxisNo.ZAxis].feedback.state.DriveManagment.InHandoverPositionWindow
					THEN
						IF	Stepper  AND
							(NOT CbaPneumatic)
							THEN
								StepNew	:=	31375;
						ELSIF	CbaPneumatic AND
								(NOT Stepper)
							THEN
								StepNew	:=	31400;		(*CbaPneumatic To front Position*)
						END_IF;
				END_IF;

	(*----------------------------------------------------------------Move A-Stepper To Ref Position----------------------------------------------------------------------*)
	31375:
			IF 	StepAction AND
				(NOT  StepActionImpulse)
				THEN
					AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartMinus				:=	FALSE;
					AxisCtrl[AxisNo.AAxis].Command.ExternalControl.StartPlus				:=	FALSE;;
					StepNew					:=	31450;
					StartMonitoringAaxis		:=	FALSE;
			END_IF;
	(*-----------------------------------------------Cylindre To Front Position---------------------------------------------------------------------*)
	31400:
			(*Action*)
			IF 	StepActionImpulse AND
				(NOT MachineCtrl.State.ChipBreaker.Auto.TurbinePosition.InFrontPosition)
				THEN
					MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdBackward	:=	FALSE;
					MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdForward	:=	TRUE;
			END_IF;
			(*Transition*)
			IF 	StepAction AND
				(NOT StepActionImpulse) AND
				((NOT MachineCtrl.Peripheral.ChipBreaker.Auto.TurbinePosition.CmdForward) AND
				 MachineCtrl.State.ChipBreaker.Auto.TurbinePosition.InFrontPosition AND
				CbaPneumatic) OR Stepper
				THEN
					StepNew		:=	31450;						(*chipBreaker SU---&gt; HomePos*)
			END_IF;
	(*-------------------------------------------------------Chip Breaker Swivel Unit To Home Position------------------------------------------*)
	31450:
			(*Action *)
			IF 	StepActionImpulse AND
				(NOT MachineCtrl.State.ChipBreaker.Auto.SwivelUnit.InHomePosition)
				THEN
					MachineCtrl.Peripheral.ChipBreaker.Auto.SwivelUnit.CmdHomePos	:=	TRUE;
					MachineCtrl.Peripheral.ChipBreaker.Auto.SwivelUnit.CmdWorkPos	:=	FALSE;
			END_IF;

			(*Transition : Is Chip Breaker In Work Position?*)

			IF 	StepAction AND
			   	 (NOT StepActionImPulse) AND
			     	MachineCtrl.State.ChipBreaker.Auto.SwivelUnit.InHomePosition
				THEN
					StepNew		:=	31500;					(*STOP*)
			END_IF;
	(*--------------------------------------------------------------Wait For User Interaction----------------------------------------------------------------------*)
	31500:
			IF	StepActionImpulse
				THEN
					NextStepPulse	:=	TRUE;
			END_IF;

			IF	StepAction AND
				( RTrigNextStep.Q OR
				ContinousMode )
				THEN
					StepNew			:= 	31550; 				(*Move Z -axis To Handover Position*)
					NextStepPulse	:=	FALSE;
			END_IF;
		(*-----------------------------------------------------------Wait For User Interaction----------------------------------------------------------------*)
	31550:
			IF	StepActionImpulse
				THEN
					NextStepPulse	:=	TRUE;
			END_IF;

			IF	StepAction AND
				( RTrigNextStep.Q OR
				ContinousMode )
				THEN
					IF CbaLimit
						THEN
							ZAxisLimitPos	:=	FALSE;
							ZaxisCbaLimit	:=	TRUE;
							StepNew			:= 	10;
							NextStepPulse	:=	FALSE;
							StopChipBreaker	:=	TRUE;
							KeyNextStep		:=	FALSE;
							CbaLimit			:=	FALSE;
						ELSE
							IF	WarningAaxis
								THEN
									WarningAaxisIsSlow	:=	TRUE;	;
							END_IF;
							IF	CbaSpindleLowSpeed
								THEN
									CbaSpindleLowSpeedOutput	:=	TRUE;
							END_IF;
							ZaxisCbaLimit	:=	FALSE;
							StepNew			:= 	10;
							NextStepPulse	:=	FALSE;
							StopChipBreaker	:=	TRUE;
							KeyNextStep		:=	FALSE;
					END_IF;
			END_IF;

		(*--------------------------------------------------------------------Deactivate Axis---------------------------------------------------------------------*)

	31600 :
			(*Action*)
			IF	StepActionImPulse
				THEN
				(* set axis state for check *)
					AxisState	:=	STATE_DISABLED;
					(*X-Axis*)
					AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdPowerOn						:=	FALSE;
					AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdMoveAbsolut					:=	FALSE;
					AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJog							:=	FALSE;
					AxisCtrl[AxisNo.XAxis].Command.OperationMode.CmdJogHandwheel					:=	FALSE;
				(* Reset z-axis *)
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdPowerOn						:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdMoveAbsolut					:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJog							:=	FALSE;
					AxisCtrl[AxisNo.ZAxis].Command.OperationMode.CmdJogHandwheel					:=	FALSE;
					(* Reset Y-axis *)
					AxisCtrl[AxisNo.YAxis].Command.OperationMode.CmdPowerOn						:=	FALSE;
					AxisCtrl[AxisNo.YAxis].Command.OperationMode.CmdMoveAbsolut					:=	FALSE;
					AxisCtrl[AxisNo.YAxis].Command.OperationMode.CmdJog							:=	FALSE;
					AxisCtrl[AxisNo.YAxis].Command.OperationMode.CmdJogHandwheel					:=	FALSE;

					MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn							:=	FALSE;
					MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.IsDeactivated			:=	FALSE;
			END_IF;

			(* transition *)
			IF	StepAction AND
				(NOT StepActionImPulse) AND
				(* all axis are disabled *)
					Axis[AxisNo.XAxis].Status.Disabled  AND
					Axis[AxisNo.ZAxis].Status.Disabled AND
					Axis[AxisNo.YAxis].Status.Disabled
				THEN
					StepNew	:= 31610;							(* -&gt; Activate Safety State*)
			END_IF;
		(* ----------------------------------------------------------------------- Activate Safety State-----------------------------------------------------------------------*)
	31610:
			(*Action*)
			IF	StepActionImPulse
				THEN
					MachineCtrl.Peripheral.ChipBreaker.Auto.DustFan.CmdOn			:=	FALSE;
					MachineCtrl.Peripheral.SafetyState.CmdActivate					:=	TRUE;
					MachineCtrl.Peripheral.ExternalControl.StatusLedOnTouch1			:=	FALSE;
					MachineCtrl.Peripheral.ExternalControl.StatusLedOnTouch2			:=	FALSE;
			END_IF;

			(*Transition*)
			IF	StepAction AND
			(NOT StepActionImPulse) AND
			( NOT MachineCtrl.Peripheral.SafetyState.CmdDeactivate ) AND
			MachineCtrl.state.SafetyState.unit.IsActive
			THEN
					MachineCtrl.Peripheral.ChipBreaker.Auto.LowSpeedMonitoring.IsDeactivated		:=	FALSE;
					MachineCtrl.ProcessControl.Event.En											:=	FALSE;
					StopChipBreaker	:=	TRUE;
					StepNew	:= 0;
			END_IF;

		(*#######################################END-Stop_Process#################################################*)

	END_CASE;

		ACT_Pneumatic();
		ACT_Stepper();


	ACT_TIME();

	StepperResults(
					sNetId					:=	'' ,
					sPathName				:= 	'C:\Loroch.UI\Beckhoff\StepperResults',
					FileName				:= 	'CbaStepperResults',
					FileNameExtension		:=	FileNameExtension ,
					bExecute				:= 	StartWriting,
					StartTime				:=	stTimeStartM ,
					EndTime					:=	stTimeEndM ,
					SawBladeWidth			:=	UI.Order.SawBlade.Width ,
					ZaxisStartPos				:=	ZPosition,
					MeasurmentFailed		:=	'' ,
					NominalRefPosition		:= 	AaxisRefPosTemp,
					Duration					:=	DurationAaxisMotion ,
					EdgeFront				:=	(*MarginFrontValue ,*)SecondEdge,
					EdgeRear				:=	(*MarginRearValue ,*)AaxisRefPosTemp,
					ZaxisTouchPosition		:=	ZposForCsv ,
					Busy					=&gt; ,
					Error					=&gt; ,
					ErrId					=&gt; 			);





























































</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/interfaceasplaintext" handleUnknown="implementation">
            <InterfaceAsPlainText>
              <xhtml xmlns="http://www.w3.org/1999/xhtml">FUNCTION_BLOCK FB_SFC_CHIPBREAKER_AUTO
(*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			Date	I	version	I	remarks
					I			I
					I			I
					I			I
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------*)
VAR_INPUT
				(*Positionierung Manuelle*)
				YDistanceToTouchPos					:	LREAL;
				ManPosActive							:	BOOL;
				XMoveManual							:	BOOL;
				SimpleTouch								:	BOOL;			(*Only 1 Touch*)
				KeyNextStep								:	BOOL;
				YrefPos									:	LREAL;			(*Reference Position  of Y-Axis)*)
				DoubleTouch								:	 BOOL;
				WorkingAngle							:	LREAL;
				Reset									:	 BOOL;
				PauseSwitchActive						:	 BOOL;
				MachineStateSafetyStateActive				:	 BOOL;
				MachineStateSharpenerDoorIsClosed		:        	BOOL;
				Start										:	 BOOL;
				AutomaticMode							:	 BOOL;
				ActualSawBlade							:	ST_SawBlade;
				ActualGrindingWheel						:	ST_GrindingWheel;
				ActualJob								:	ST_Job;
				AStartPos								:	 LREAL;				(*Rear Pos*)
				ChamferSideString						:	 STRING;
				ToothPitch								:	 LREAL;
				GrindingDirCW							:	 BOOL;
				DeltaMax								:	LREAL;
				TeethNumber								:	 INT;
				Stepper									:	 BOOL;							(*Using Servo Motor*)
				CbaPneumatic							:	BOOL;
				Zx										:	LREAL;							(*Z_Axis Corrector*)
				(*stepper-servo*)
				MarginRearValue							:	LREAL;							(*this value: Randabstand rear side to be set by the user*)
				MarginFrontValue							:	LREAL;							(*this value: Randabstand front side to be set by the user*)
				CbaMotionType							:	E_MotionType;
END_VAR
VAR_OUTPUT
				ActualStep								:	 INT;
				ErrorID									:	 DINT;
				ErrorOut									:	 BOOL;
				Paused									: 	BOOL;
				PauseRequest							:	 BOOL;
				PauseAvailable							:	 BOOL;
				CammingActive							:	 BOOL;
				ActualRevolutions							:     	UINT;
				ZStartposBuffered							:	 LREAL;
				ActualInfeed								:	LREAL;							(* actual infeed *)
				PartialInfeed								:	LREAL;
				ToothCount								:	INT;
				ZaxisCbaLimit							:	BOOL;
				CBAutoNotPossibleWithTooLargeSbDiameter	:	BOOL;
				WarningAaxisIsSlow						:	BOOL;
				CbaSpindleLowSpeedOutput				:	BOOL;

END_VAR

VAR_IN_OUT
				Done									:	BOOL;
				TouchPositionZAxis						:	LREAL;
				ChipBreakerAutoVeloTemp					:	LREAL;
				ChipBreakerManVeloOverrideFactor			:	LREAL;
END_VAR

VAR
				(*Manual Positionning*)
				RTrigConfirmTouchposZ					:	 R_TRIG;
				RTrigConfirmTouchposX					:	 R_TRIG;
				TON_Wait								:	 TON;
				DeltaXChamfering							:	 LREAL;
				ActualTeeth								:	 INT;
				SfcChipBreakerAuto						:	 FB_SUBFUNC_SEQ_CONTROL;	(* FB sfc *)
				XAxisStartPosition 							:	 LREAL;
				ZAxisStartPosition							:	 LREAL;
				ChipBreakerRear							:	 BOOL;
				StepNew									:	 INT;
				StepAction								:	 BOOL;
				StepActionImPulse						:	 BOOL;
				PauseStep								:	 INT;
				WorkingStepNo							:	 INT;
				AxisState								:	 E_StateMachineAxis;				(* check state of axis *)
				SBCircumference							:	 LREAL;
				ChipBreakerXAxisVelo						:	 LREAL;
				ChipBreakerAutoXAxisMaxVelo				: 	 LREAL;
				YAxisStartPosition							:	 LREAL;
				DegPerTeeth								:	 LREAL;
				XAxisTouchposRadio						:	 LREAL;
				TouchCorrection							:	 LREAL;
				FBCalcXOffset							:	 LREAL;
				XOffset									:	 LREAL;
				ZOffset									:	 LREAL;
				VarioCtr									:	 INT;
				VarioCtrEnd								:	 INT;
				XAxisEndPos								:	 LREAL;
				ZTouchPos								:	 LREAL;
				NumberTouch							:	 INT ;
				Delta									:         LREAL;			(*ABS(TP1-TP2)*)
				NominalTeeth							:	 LREAL;
				PauseRequested							:	 BOOL;
				PartialInfeedChangedDownfeed				:	 BOOL;
				ZAxisPausePos							:	 LREAL;
				InfeedZAxisMM							:	 LREAL;
				TouchPositionsZPlausi						:	 ARRAY[0..2] OF LREAL;
				TouchPositionsPlausibilityOK				:	 BOOL;
				TouchPositionsPlausibilityError				:	 BOOL;
				ChipBreakerFront							:	 BOOL;
				XaxisEndPOsFront						:	 LREAL;			(*X-Axis End Position After The Sharpening *)
				DeltaX									:	 LREAL;
				DeltaZ									:	 LREAL;
				YendPos								:	 LREAL;			(*End Position Y-Axis after Grinding*)
				ZAxisUpfeedMM							:	 LREAL;
				ZAxisUpfeedPosition						:	 LREAL;
				WorkingAngleRAD						:	 LREAL;
				RSS									:	 LREAL;
				BSS										:	 LREAL	;
				ChipBreakerFr							:	 BOOL	:=	TRUE;
				ChipBreakerRe							:	 BOOL	:=	FALSE ;
				NumberRevolution						:	 INT:=0	     ;
				ActualGrindingWheelThickness				:	 LREAL;
				(*Enumeration added*)
				RTrigNextStep							:	R_TRIG;
				ContinousMode							:	 BOOL;
				NextStepPulse							:	BOOL;
				XPosition								:	LREAL;
				ZPosition								:	LREAL;
				TON_Rear								:	TON;							(*Delay before the start of the Rear Side*)
				TONWaitSafetyStatePause					:	TON;
				FTRIG_STOP							:	F_TRIG;
				DeltaX_DEG								:	LREAL;
				XoffsetInGrad								:	LREAL;
				TonWaitClamping							:	TON;
				Test										:	BOOL;
				StopChipBreaker							:	BOOL;
				StartButton								:	R_TRIG;
				Stop_Manual_Pos							:	F_TRIG;
				DSSDiff									:	LREAL;
				ZPosAfterSharpening						:	LREAL;
				(*Software Limit S*)
				ZAxisLimitPos							:	BOOL;
				R_TRIG_ZlimitPos							:	R_TRIG;
				CbaLimit									:	BOOL;
				WaitAfterPause							:	TON;
				(*Vario*)
				VarioToothPitch							:	ARRAY[0..11] OF LREAL;
				VarioCtrFront1							:	INT;
				VarioCtrFront2							:	INT;
				VarioCtrRear1							:	INT;
				VarioCtrRear2							:	INT;
				GearPlayXAxis							:	LREAL;
				DifferenceMaxMinCBAGWDiameter			:	LREAL;
				(*Display Warning*)
				UIEventCBAProtection						:	FB_SUBFUNC_MESSAGE;
				ChipBreakerAutoGWwidth					:	LREAL;
				AaxisReferenceValue						:	LREAL;    (*the initial distance in MM when the axis is in home position*)
				AFront80									:	LREAL;	(*80% of the A-Axis front destination*)
				ARear80									:	LREAL;	(*80 % of the A -Axis Rear position *)
				AaxisRef80								:	LREAL;	(**)
				ARearPos								:	LREAL;
				AFrontPos								:	 LREAL;
				TonMonitoringAaxis						:	TON;
				StartMonitoringAaxis						:	BOOL;
				WarningAaxis								:	BOOL;
				RtrigAaxisIsTooSlow						:	R_TRIG;
				RtrigSpindleLowSpeedError				:	R_TRIG;
				CbaSpindleLowSpeed						:	BOOL;
				TriesNumber								:	INT;  (*Number of tries to find out the Reference position of A-axis*)
				AaxisRefPosTemp						:	LREAL;
				AaxisActPosition							:	LREAL;
				StartMovingStepByStepRear				:	BOOL; (**)
				StartMovingStepByStepFront				:	BOOL;
				ZTouchPosFirstTouchPos					:	LREAL;
				AaxisStepPositionIsReached				:	BOOL;
				WaitForAaxis								:	TON;
				StartWaitAaxis							:	BOOL;
				ZaxisFirstTouchPos						:	LREAL;
				ZNoTouch								:	LREAL;
				LastZPos								:	LREAL;
				LimitZaxis								:	LREAL;
				Zcomp									:	LREAL;
				StepperResults							:	FB_StepperResults;
				FileNameExtension						:	T_MaxString;
				StartWriting								:	BOOL;
				FileName								:	STRING;
				stTimeStruct								: 	TIMESTRUCT;
				stTimeStartM								: 	TIMESTRUCT;
				stTimeEndM								: 	TIMESTRUCT;
				ZposForCsv								:	LREAL;
				DurationAaxisMotion						:	TIME;
				StartTimeCounting							:	BOOL;
				TonCounting								:	TP;
				fbGetTime								: 	NT_GetTime;
				FirstEdgePos								:	LREAL;
				TestZ									:	BOOL;
				SecondEdge								:	LREAL;
				StepMotorNeededTimeToMove				:	TIME;
				StepMotorDestination						:	LREAL;
				AaxisTolerenceFast						:	LREAL;
				AaxisTolerenceSlow						:	LREAL;
				RTrigMonitoringCrash						:	R_TRIG;
				MonitoringTouchBack						:	LREAL;
				MonitoringTouchFront						:	LREAL;
				OperatingDirection						:	ST_OperatingDirection;
				TestCW									:	BOOL;
				TestCCW								:	BOOL;
				CalculatedXPosition,DiffXactposXcalcPos		:	LREAL;
				NumberOfTeethToAddReal					:	LREAL;
				NumberOfTeethToAdd						:	INT;
				rValueToAdd								:	LREAL;
				NombreOfRevolution						:	INT;
				GearPlayXAxisSharpChamfer				:	LREAL;
				(* Compensation *)
				NoOfActTeethCompensation				:	INT;
				XAxisNextPosition							:	LREAL;
				TestArray								:	ARRAY[0..5] OF BOOL;
END_VAR
</xhtml>
            </InterfaceAsPlainText>
          </data>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>9327d967-9c1d-46d5-bf69-8297bcda22cf</ObjectId>
          </data>
        </addData>
      </pou>
    </pous>
  </types>
  <instances>
    <configurations />
  </instances>
  <addData>
    <data name="http://www.3s-software.com/plcopenxml/projectstructure" handleUnknown="discard">
      <ProjectStructure>
        <Object Name="FB_SFC_CHIPBREAKER_AUTO" ObjectId="9327d967-9c1d-46d5-bf69-8297bcda22cf">
          <Object Name="ACT_Pneumatic" ObjectId="546b885e-675a-4e8c-bcf1-7440e2a398b1" />
          <Object Name="ACT_Stepper" ObjectId="5770a76c-d671-4cc6-a170-d5a7657850c8" />
          <Object Name="ACT_TIME" ObjectId="43d769c7-4fd6-40fe-a336-0d3a3ff4e30c" />
        </Object>
      </ProjectStructure>
    </data>
  </addData>
</project>